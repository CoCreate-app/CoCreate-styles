/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/CoCreate-styles.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/CoCreate-styles.js":
/*!********************************!*\
  !*** ./src/CoCreate-styles.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*global MutationObserver*/\n\n/**\n * data-style: classStyle | style | attribute\n * data-style_sync: any valid css property\n * data-style_unit: any valid css unit type\n * data-style_target: unique id of element written to data-element_id\n */\n// todo: disable input when there is no data-style, there is no reason it to have default value it should be\n// disabled\n// import { refs as pickrRefs } from '../../CoCreate-builder/src/pickr.js';\n//dummy change 2\nvar pickrRefs = window.CoCreatePickr.refs;\nvar filters = [];\nvar allFrames = new Map();\n\nfunction allFrame(callback) {\n  var result = new Set();\n\n  var _iterator = _createForOfIteratorHelper(allFrames),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          frameObject = _step$value[0],\n          frame = _step$value[1];\n\n      var callbackResult = callback(frame.document, frame.window);\n      if (callbackResult && typeof callbackResult[Symbol.iterator] === \"function\") callbackResult.forEach(function (el) {\n        return result.add(el);\n      });else if (callbackResult) result.add(callbackResult);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Array.from(result).filter(function (el) {\n    return !filters.some(function (filter) {\n      return el.matches(filter);\n    });\n  });\n}\n\nfunction watchInputChange(mutation) {\n  var inputMeta = validateNewInput(mutation.target);\n  if (!inputMeta) return;\n\n  if (mutation.attributeName === \"data-style_target\") {\n    var element = getElement(inputMeta.input);\n    if (element) updateInput(element, [inputMeta.input]);\n  } // else if (mutation.attributeName === \"value\") {\n  //   let { input, dataAttribute, dataProperty } = inputMeta;\n  //   let elementId = input.getAttribute(\"data-style_target\");\n  //   updateElement(inputMeta, elementId, true);\n  // }\n\n} // function watchElementChange(mutationsList, observer) {\n//   for (let mutation of mutationsList) {\n//     updateInput(mutation.target);\n//   }\n// }\n// function watchInputChange(mutationsList, observer) {\n//   watchElementChangeObserver.disconnect();\n//   for (let mutation of mutationsList)\n//     if (\n//       // mutation.target.isReactive !== false &&\n//       mutation.type === \"attributes\" &&\n//       mutation.target.tagName === \"INPUT\"\n//     ) {\n//       let inputMeta = validateNewInput(mutation.target);\n//       if (!inputMeta) return;\n//       if (mutation.attributeName === \"data-style_target\") {\n//         let element = getElement(inputMeta.input);\n//         // mutation.target.isReactive = false;\n//         updateInput(element, [inputMeta.input]);\n//       } else {\n//         updateElement(inputMeta);\n//       }\n//     }\n//   watchElementChangeObserver.observe(canvas, configElement);// todo: no canvas\n// }\n// canvas.body.addEventListener(\"click\", (e) => {\n//   updateInput(e.target)\n// });\n\n\nfunction getInputs(element) {\n  var inputs = [];\n  var allInputs = Array.from(document.getElementsByTagName(\"input\"));\n  allInputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var allReferencedEl = allFrame(function (frame) {\n      return frame.querySelectorAll(inputMeta.input.getAttribute(\"data-style_target\"));\n    });\n\n    if (Array.from(allReferencedEl).includes(element)) {\n      inputs.push(inputMeta.input);\n    }\n  });\n  return inputs;\n}\n\nfunction getElement(input) {\n  var id = input.getAttribute(\"data-style_target\");\n  if (id) return allFrame(function (frame) {\n    return frame.querySelector(id);\n  })[0];else return false;\n} // function getRealStaticCompStyleOld(element) {\n//   // calculate real css instead of comupted element\n//   watchElementChangeObserver.disconnect();\n//   let oldDispaly = element.style.display;\n//   element.style.display = \"none\";\n//   let computedStylesLive = window.getComputedStyle(element);\n//   let computedStyles = Object.assign({}, computedStylesLive);\n//   computedStyles.display = oldDispaly;\n//   element.style.display = oldDispaly;\n//   if (element.getAttribute(\"style\") == \"\") element.removeAttribute(\"style\");\n//   watchElementChangeObserver.observe(canvas, configElement);\n//   return computedStyles;\n// }\n// function getAllStyles() {\n//   for (let styleSheet of document.styleSheets) {\n//     let style;\n//     try {\n//       style = styleSheet.cssRules || styleSheet.rules;\n//     } catch (error) {\n//       console.log(\"couldn't parse style\");\n//     }\n//     if(!style) continue;\n//       for (let rule of style) {\n//         let selector = rule.selectorText;\n//         querySelectorAll\n//       }\n//     style = undefined;\n//   }\n// }\n// getAllStyles();\n\n\nvar cache = new Map();\n\nfunction getRealStaticCompStyle(element) {\n  var shouldCache = false;\n\n  if (cache.has(element)) {\n    return cache.get(element);\n  } else if (cache.length < 10) {\n    shouldCache = true;\n  } // calculate real css instead of comupted element\n  // watchElementChangeObserver.disconnect();\n\n\n  var oldDispaly = element.style.display; // element.setAttribute('no-observe', true)\n\n  element.style.display = \"none\";\n  var computedStylesLive = window.getComputedStyle(element);\n  var computedStyles = Object.assign({}, computedStylesLive);\n  computedStyles.display = oldDispaly;\n  element.style.display = oldDispaly;\n  if (element.getAttribute(\"style\") == \"\") element.removeAttribute(\"style\"); // element.removeAttribute('no-observe')\n  // watchElementChangeObserver.observe(canvas, configElement);\n\n  if (shouldCache) cache.set(element, computedStyles);\n  return computedStyles;\n}\n\nfunction validateNewInput(input) {\n  var dataAttribute = input.getAttribute(\"data-style\");\n  if (!dataAttribute) return; // console.warn(\"cc-style: input doesn't have data-style\")\n\n  dataAttribute = dataAttribute.toLowerCase();\n  var dataProperty = input.getAttribute(\"data-style_sync\");\n  if (!dataProperty) return; // console.warn(\"cc-style: input doesn't have data-style\")\n\n  dataProperty = dataProperty.toLowerCase();\n  return {\n    input: input,\n    dataAttribute: dataAttribute,\n    dataProperty: dataProperty\n  };\n}\n\nfunction parseUnit(style) {\n  var value = parseFloat(style);\n\n  if (!isNaN(value)) {\n    var valueLength = (value + \"\").length;\n    return [value, style.substr(valueLength) || \"none\"];\n  }\n\n  return [style, \"\"];\n}\n\nfunction getCoCreateStyle(classList) {\n  var styles = {};\n  classList.forEach(function (classname) {\n    var _classname$split = classname.split(\":\"),\n        _classname$split2 = _slicedToArray(_classname$split, 2),\n        name = _classname$split2[0],\n        value = _classname$split2[1];\n\n    styles[name] = value;\n  });\n  return styles;\n}\n\nfunction putCoCreateStyle(classList, newStyles) {\n  var styleMap = new Map();\n  classList.forEach(function (classname) {\n    var _classname$split3 = classname.split(\":\"),\n        _classname$split4 = _slicedToArray(_classname$split3, 2),\n        name = _classname$split4[0],\n        value = _classname$split4[1];\n\n    styleMap.set(name, value);\n  });\n\n  for (var _i2 = 0, _Object$entries = Object.entries(newStyles); _i2 < _Object$entries.length; _i2++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n        name = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (styleMap.has(name)) {\n      var _value = styleMap.get(name);\n\n      classList.remove(name + \":\" + _value);\n    }\n\n    classList.add(name + \":\" + value);\n  }\n}\n\nfunction removeccCssStyle(classList, property) {\n  var coCreateCss = getCoCreateStyle(classList);\n  delete coCreateCss[property];\n  putCoCreateStyle(classList, coCreateCss);\n}\n\nfunction assignElementId(element) {\n  var isReactive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var inputs = Array.from(document.getElementsByTagName(\"input\"));\n  inputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var input = inputMeta.input,\n        dataAttribute = inputMeta.dataAttribute,\n        dataProperty = inputMeta.dataProperty;\n    input.isReactive = isReactive;\n    var elementId = element.getAttribute(\"data-element_id\");\n    input.setAttributeIfDiffer(\"data-style_target\", \"[data-element_id=\".concat(elementId, \"]\"));\n  });\n} // picked up from stackoverflow\n\n\nfunction rgba2hex(orig) {\n  var a,\n      isPercent,\n      rgb = orig.replace(/\\s/g, '').match(/^rgba?\\((\\d+),(\\d+),(\\d+),?([^,\\s)]+)?/i),\n      alpha = (rgb && rgb[4] || \"\").trim(),\n      hex = rgb ? (rgb[1] | 1 << 8).toString(16).slice(1) + (rgb[2] | 1 << 8).toString(16).slice(1) + (rgb[3] | 1 << 8).toString(16).slice(1) : orig;\n\n  if (alpha !== \"\") {\n    a = alpha;\n  } else {\n    a = 1;\n  } // multiply before convert to HEX\n\n\n  a = (a * 255 | 1 << 8).toString(16).slice(1);\n  hex = hex + a;\n  return hex;\n} // mutation reflect data-style_unit\n\n\nfunction setPlaceHolders(element) {\n  var inputs = getInputs(element);\n  inputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var input = inputMeta.input,\n        dataAttribute = inputMeta.dataAttribute,\n        dataProperty = inputMeta.dataProperty;\n    var cmlDataProperty = toCamelCase(dataProperty);\n    var elementId = element.getAttribute(\"data-element_id\");\n    if (!elementId) return;\n    var inputElementId = input.getAttribute(\"data-style_target\");\n\n    if (elementId != inputElementId) {\n      var computedStyles = getRealStaticCompStyle(element);\n      var style;\n\n      switch (dataAttribute) {\n        case \"style\":\n          style = computedStyles[cmlDataProperty];\n          break;\n\n        case \"classstyle\":\n          var coCreateCss = getCoCreateStyle(element.classList);\n          style = coCreateCss[cmlDataProperty];\n          if (!style) style = computedStyles[cmlDataProperty];\n          break;\n\n        default:\n          style = computedStyles[cmlDataProperty];\n      } // style= true;\n      // update style unit\n      // todo: why it's look like update input? should i update?\n\n\n      if (style) {\n        var _parseUnit = parseUnit(style),\n            _parseUnit2 = _slicedToArray(_parseUnit, 2),\n            value = _parseUnit2[0],\n            unit = _parseUnit2[1];\n\n        switch (input.type) {\n          case 'file':\n            break;\n\n          case 'color':\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = rgba2hex(value);\n            break;\n\n          default:\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = value + '';\n        }\n\n        input.setAttributeIfDiffer(\"data-style_unit\", unit || '');\n      }\n    }\n  });\n}\n\nfunction updateInput(element, inputs) {\n  var computedStyles = getRealStaticCompStyle(element); // let computedStyles = {};\n\n  if (!inputs) inputs = getInputs(element);\n  inputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var input = inputMeta.input,\n        dataAttribute = inputMeta.dataAttribute,\n        dataProperty = inputMeta.dataProperty;\n    var cmlDataProperty = toCamelCase(dataProperty);\n    var elementId = element.getAttribute(\"data-element_id\");\n    if (!elementId) return; //calculate style\n\n    var style;\n\n    switch (dataAttribute) {\n      case \"style\":\n        style = computedStyles[cmlDataProperty];\n        break;\n\n      case \"classstyle\":\n        var coCreateCss = getCoCreateStyle(element.classList);\n        style = coCreateCss[cmlDataProperty];\n        if (!style) style = computedStyles[cmlDataProperty];\n        break;\n\n      default:\n        style = computedStyles[cmlDataProperty];\n    } // update style unit\n\n\n    if (style) {\n      var _parseUnit3 = parseUnit(style),\n          _parseUnit4 = _slicedToArray(_parseUnit3, 2),\n          value = _parseUnit4[0],\n          unit = _parseUnit4[1];\n\n      if (inputMeta.input.classList.contains('pickr')) {\n        if (!pickrRefs.has(input)) return;\n        var pickrIns = pickrRefs.get(input);\n        window.CoCreatePickr.disabledEvent = true;\n        pickrIns.setColor(style);\n        window.CoCreatePickr.disabledEvent = false;\n      } else {\n        switch (input.type) {\n          case 'file':\n            break;\n\n          case 'color':\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = rgba2hex(value);\n            break;\n\n          default:\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = value + '';\n        }\n      }\n\n      input.setAttributeIfDiffer(\"data-style_unit\", unit || '');\n    }\n  });\n}\n\nfunction updateElementValue(value, dataAttribute, dataProperty, elementId) {\n  var element = allFrame(function (frame) {\n    return frame.querySelector(elementId);\n  })[0];\n  var camelDataProperty = toCamelCase(dataProperty);\n\n  switch (dataAttribute) {\n    case \"classstyle\":\n      element.setCCStyle(dataProperty, value);\n      break;\n\n    case \"style\":\n      element.setStlyeIfDiffer(camelDataProperty, value);\n      break;\n\n    default: // code\n\n  }\n}\n\nfunction updateElement(inputMeta, elementId, isColl) {\n  var element = allFrame(function (frame) {\n    return frame.querySelector(elementId);\n  })[0];\n  var input = inputMeta.input,\n      dataProperty = inputMeta.dataProperty,\n      dataAttribute = inputMeta.dataAttribute;\n  var camelDataProperty = toCamelCase(dataProperty);\n  var style;\n\n  if (input.classList.contains('pickr')) {\n    if (!pickrRefs.has(input)) return;\n    var pickrIns = pickrRefs.get(input);\n    style = pickrIns.getColor().toHEXA().toString();\n\n    switch (dataAttribute) {\n      case \"classstyle\":\n        element.setCCStyle(dataProperty, style);\n        isColl && collaborate({\n          value: style,\n          unit: '',\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        });\n        break;\n\n      case \"style\":\n        element.setStlyeIfDiffer(camelDataProperty, style) && isColl && collaborate({\n          value: style,\n          unit: '',\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        });\n        break;\n\n      default: // code\n\n    }\n  } else {\n    var _parseUnit5 = parseUnit(input.value),\n        _parseUnit6 = _slicedToArray(_parseUnit5, 2),\n        value = _parseUnit6[0],\n        unit = _parseUnit6[1];\n\n    unit = input.getAttribute(\"data-style_unit\");\n\n    switch (dataAttribute) {\n      case \"classstyle\":\n        // when input is empty remove that style\n        if (!input.value) {\n          removeccCssStyle(element.classList, dataProperty);\n          isColl && collaborate({\n            value: value,\n            input: input,\n            dataProperty: dataProperty,\n            dataAttribute: dataAttribute,\n            element: element,\n            elementId: elementId\n          });\n          return;\n        } // when there is style set that\n\n\n        style = value + unit;\n        element.setCCStyle(dataProperty, style);\n        isColl && collaborate({\n          value: value,\n          unit: unit,\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        });\n        break;\n\n      case \"style\":\n        // let computedStyles = getRealStaticCompStyle(element);\n        // let styleValue = computedStyles[dataProperty];\n        if (!input.value) {\n          element.setStlyeIfDiffer(camelDataProperty, \"\") && isColl && collaborate({\n            value: value,\n            input: input,\n            dataProperty: dataProperty,\n            dataAttribute: dataAttribute,\n            element: element,\n            elementId: elementId\n          }); // element.style[dataProperty] = \"\";\n\n          return;\n        }\n\n        style = value + unit;\n        element.setStlyeIfDiffer(camelDataProperty, style) && isColl && collaborate({\n          value: value,\n          unit: unit,\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        }); // element.style[dataProperty] = style;\n\n        break;\n\n      default:\n    }\n  }\n}\n\nfunction toCamelCase(str) {\n  var index = 0;\n\n  do {\n    index = str.indexOf(\"-\", index);\n\n    if (index !== -1) {\n      var t = str.substring(0, index);\n      t += String.fromCharCode(str.charCodeAt(index + 1) - 32);\n      t += str.substr(index + 2);\n      str = t;\n    } else break;\n  } while (true);\n\n  return str;\n}\n\nfunction setAttributeIfDiffer(property, value) {\n  if (this.getAttribute(property) !== value) this.setAttribute(property, value);\n}\n\nfunction setStlyeIfDiffer(property, value) {\n  var computedStyles = getRealStaticCompStyle(this);\n\n  if (computedStyles[property] !== value) {\n    this.style[property] = value;\n    return true;\n  } else return false;\n}\n\nfunction addClassIfDiffer(className) {\n  if (!this.classList.has(className)) this.classList.add(className);\n}\n\nfunction setCCStyle(property, newValue) {\n  var _iterator2 = _createForOfIteratorHelper(this.classList),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var classname = _step2.value;\n\n      var _classname$split5 = classname.split(\":\"),\n          _classname$split6 = _slicedToArray(_classname$split5, 2),\n          name = _classname$split6[0],\n          value = _classname$split6[1];\n\n      if (name === property) {\n        this.classList.replace(classname, property + \":\" + newValue);\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  this.classList.add(property + \":\" + newValue);\n}\n\nfunction getCCStyle(property) {\n  var styleMap = new Map();\n\n  var _iterator3 = _createForOfIteratorHelper(this.classList),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var classname = _step3.value;\n\n      var _classname$split7 = classname.split(\":\"),\n          _classname$split8 = _slicedToArray(_classname$split7, 2),\n          name = _classname$split8[0],\n          value = _classname$split8[1];\n\n      if (name === property) {\n        return value;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nvar tools = {};\n\nfunction init(_ref) {\n  var windowObject = _ref.windowObject,\n      docObject = _ref.docObject,\n      isIframe = _ref.isIframe,\n      frame = _ref.frame,\n      onCollaboration = _ref.onCollaboration;\n  var ref;\n  tools.onCollaboration = onCollaboration;\n\n  if (isIframe) {\n    var frameWindow = frame.contentWindow;\n    var frameDocument = frameWindow.document || frame.contentDocument;\n    ref = {\n      frame: frame,\n      window: frameWindow,\n      document: frameDocument,\n      isIframe: true\n    };\n    allFrames.set(frame, ref);\n  } else {\n    ref = {\n      window: windowObject,\n      document: docObject,\n      isIframe: false\n    };\n    allFrames.set(\"main\", ref);\n  }\n\n  ref.window.HTMLElement.prototype.setAttributeIfDiffer = setAttributeIfDiffer;\n  ref.window.HTMLElement.prototype.setStlyeIfDiffer = setStlyeIfDiffer;\n  ref.window.HTMLElement.prototype.addClassIfDiffer = addClassIfDiffer;\n  ref.window.HTMLElement.prototype.setCCStyle = setCCStyle;\n  ref.window.HTMLElement.prototype.getCCStyle = getCCStyle;\n  ref.window.addEventListener(\"load\", function () {\n    ref.window.CoCreateObserver.add({\n      name: \"ccStyle\",\n      observe: [\"attributes\"],\n      attributes: [\"data-style_target\", \"value\"],\n      include: \"INPUT, .pickr\",\n      task: watchInputChange\n    });\n  });\n  ref.document.addEventListener(\"input\", function (e) {\n    var input = e.target; // input.isReactive = true;\n\n    var inputMeta = validateNewInput(input);\n    if (!inputMeta) return;\n    var elementId = input.getAttribute(\"data-style_target\");\n    updateElement(inputMeta, elementId, true);\n  });\n}\n\nfunction addFilter(selector) {\n  filters.push(selector);\n}\n\nwindow.ccStyle = {\n  init: init,\n  addFilter: addFilter\n};\nwindow.addEventListener(\"load\", function () {\n  window.CoCreateObserver.add({\n    name: \"ccStyle\",\n    observe: [\"attributes\"],\n    attributes: [\"data-style_target\", \"value\"],\n    include: \"INPUT, .pickr\",\n    task: watchInputChange\n  });\n  init({\n    windowObject: window,\n    docObject: document\n  });\n});\nCoCreateSocket.listen(\"ccStyle\", function (_ref2) {\n  var value = _ref2.value,\n      dataAttribute = _ref2.dataAttribute,\n      dataProperty = _ref2.dataProperty,\n      elementId = _ref2.elementId,\n      unit = _ref2.unit;\n  var inputs = allFrame(function (frame) {\n    return frame.querySelector(\"[data-style=\".concat(dataAttribute, \"][data-style_sync=\").concat(dataProperty, \"]\"));\n  });\n  inputs.forEach(function (input) {\n    updateElementValue(value + unit, dataAttribute, dataProperty, elementId);\n  });\n});\n\nfunction collaborate(_ref3) {\n  var value = _ref3.value,\n      input = _ref3.input,\n      dataProperty = _ref3.dataProperty,\n      dataAttribute = _ref3.dataAttribute,\n      elementId = _ref3.elementId,\n      element = _ref3.element,\n      unit = _ref3.unit;\n  // if (value != input.value) return;\n  tools.onCollaboration({\n    value: value,\n    unit: unit,\n    dataProperty: dataProperty,\n    dataAttribute: dataAttribute,\n    element: element\n  });\n  CoCreate.sendMessage({\n    broadcast_sender: false,\n    rooms: \"\",\n    emit: {\n      message: \"ccStyle\",\n      data: {\n        value: value,\n        unit: unit,\n        dataProperty: dataProperty,\n        dataAttribute: dataAttribute,\n        elementId: elementId\n      }\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29DcmVhdGUtc3R5bGVzLmpzPzQzN2UiXSwibmFtZXMiOlsicGlja3JSZWZzIiwid2luZG93IiwiQ29DcmVhdGVQaWNrciIsInJlZnMiLCJmaWx0ZXJzIiwiYWxsRnJhbWVzIiwiTWFwIiwiYWxsRnJhbWUiLCJjYWxsYmFjayIsInJlc3VsdCIsIlNldCIsImZyYW1lT2JqZWN0IiwiZnJhbWUiLCJjYWxsYmFja1Jlc3VsdCIsImRvY3VtZW50IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmb3JFYWNoIiwiZWwiLCJhZGQiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJzb21lIiwibWF0Y2hlcyIsIndhdGNoSW5wdXRDaGFuZ2UiLCJtdXRhdGlvbiIsImlucHV0TWV0YSIsInZhbGlkYXRlTmV3SW5wdXQiLCJ0YXJnZXQiLCJhdHRyaWJ1dGVOYW1lIiwiZWxlbWVudCIsImdldEVsZW1lbnQiLCJpbnB1dCIsInVwZGF0ZUlucHV0IiwiZ2V0SW5wdXRzIiwiaW5wdXRzIiwiYWxsSW5wdXRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnB1dENhbmRpZGF0ZSIsImFsbFJlZmVyZW5jZWRFbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnZXRBdHRyaWJ1dGUiLCJpbmNsdWRlcyIsInB1c2giLCJpZCIsInF1ZXJ5U2VsZWN0b3IiLCJjYWNoZSIsImdldFJlYWxTdGF0aWNDb21wU3R5bGUiLCJzaG91bGRDYWNoZSIsImhhcyIsImdldCIsImxlbmd0aCIsIm9sZERpc3BhbHkiLCJzdHlsZSIsImRpc3BsYXkiLCJjb21wdXRlZFN0eWxlc0xpdmUiLCJnZXRDb21wdXRlZFN0eWxlIiwiY29tcHV0ZWRTdHlsZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXQiLCJkYXRhQXR0cmlidXRlIiwidG9Mb3dlckNhc2UiLCJkYXRhUHJvcGVydHkiLCJwYXJzZVVuaXQiLCJ2YWx1ZSIsInBhcnNlRmxvYXQiLCJpc05hTiIsInZhbHVlTGVuZ3RoIiwic3Vic3RyIiwiZ2V0Q29DcmVhdGVTdHlsZSIsImNsYXNzTGlzdCIsInN0eWxlcyIsImNsYXNzbmFtZSIsInNwbGl0IiwibmFtZSIsInB1dENvQ3JlYXRlU3R5bGUiLCJuZXdTdHlsZXMiLCJzdHlsZU1hcCIsImVudHJpZXMiLCJyZW1vdmUiLCJyZW1vdmVjY0Nzc1N0eWxlIiwicHJvcGVydHkiLCJjb0NyZWF0ZUNzcyIsImFzc2lnbkVsZW1lbnRJZCIsImlzUmVhY3RpdmUiLCJlbGVtZW50SWQiLCJzZXRBdHRyaWJ1dGVJZkRpZmZlciIsInJnYmEyaGV4Iiwib3JpZyIsImEiLCJpc1BlcmNlbnQiLCJyZ2IiLCJyZXBsYWNlIiwibWF0Y2giLCJhbHBoYSIsInRyaW0iLCJoZXgiLCJ0b1N0cmluZyIsInNsaWNlIiwic2V0UGxhY2VIb2xkZXJzIiwiY21sRGF0YVByb3BlcnR5IiwidG9DYW1lbENhc2UiLCJpbnB1dEVsZW1lbnRJZCIsInVuaXQiLCJ0eXBlIiwiY29udGFpbnMiLCJwaWNrcklucyIsImRpc2FibGVkRXZlbnQiLCJzZXRDb2xvciIsInVwZGF0ZUVsZW1lbnRWYWx1ZSIsImNhbWVsRGF0YVByb3BlcnR5Iiwic2V0Q0NTdHlsZSIsInNldFN0bHllSWZEaWZmZXIiLCJ1cGRhdGVFbGVtZW50IiwiaXNDb2xsIiwiZ2V0Q29sb3IiLCJ0b0hFWEEiLCJjb2xsYWJvcmF0ZSIsInN0ciIsImluZGV4IiwiaW5kZXhPZiIsInQiLCJzdWJzdHJpbmciLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUF0Iiwic2V0QXR0cmlidXRlIiwiYWRkQ2xhc3NJZkRpZmZlciIsImNsYXNzTmFtZSIsIm5ld1ZhbHVlIiwiZ2V0Q0NTdHlsZSIsInRvb2xzIiwiaW5pdCIsIndpbmRvd09iamVjdCIsImRvY09iamVjdCIsImlzSWZyYW1lIiwib25Db2xsYWJvcmF0aW9uIiwicmVmIiwiZnJhbWVXaW5kb3ciLCJjb250ZW50V2luZG93IiwiZnJhbWVEb2N1bWVudCIsImNvbnRlbnREb2N1bWVudCIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkNvQ3JlYXRlT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImluY2x1ZGUiLCJ0YXNrIiwiZSIsImFkZEZpbHRlciIsInNlbGVjdG9yIiwiY2NTdHlsZSIsIkNvQ3JlYXRlU29ja2V0IiwibGlzdGVuIiwiQ29DcmVhdGUiLCJzZW5kTWVzc2FnZSIsImJyb2FkY2FzdF9zZW5kZXIiLCJyb29tcyIsImVtaXQiLCJtZXNzYWdlIiwiZGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBLElBQUlBLFNBQVMsR0FBR0MsTUFBTSxDQUFDQyxhQUFQLENBQXFCQyxJQUFyQztBQUVBLElBQUlDLE9BQU8sR0FBRyxFQUFkO0FBQ0EsSUFBSUMsU0FBUyxHQUFHLElBQUlDLEdBQUosRUFBaEI7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQkMsUUFBbEIsRUFBNEI7QUFDMUIsTUFBSUMsTUFBTSxHQUFHLElBQUlDLEdBQUosRUFBYjs7QUFEMEIsNkNBRU9MLFNBRlA7QUFBQTs7QUFBQTtBQUUxQix3REFBNEM7QUFBQTtBQUFBLFVBQWxDTSxXQUFrQztBQUFBLFVBQXJCQyxLQUFxQjs7QUFDMUMsVUFBSUMsY0FBYyxHQUFHTCxRQUFRLENBQUNJLEtBQUssQ0FBQ0UsUUFBUCxFQUFpQkYsS0FBSyxDQUFDWCxNQUF2QixDQUE3QjtBQUNBLFVBQ0VZLGNBQWMsSUFDZCxPQUFPQSxjQUFjLENBQUNFLE1BQU0sQ0FBQ0MsUUFBUixDQUFyQixLQUEyQyxVQUY3QyxFQUlFSCxjQUFjLENBQUNJLE9BQWYsQ0FBdUIsVUFBQ0MsRUFBRDtBQUFBLGVBQVFULE1BQU0sQ0FBQ1UsR0FBUCxDQUFXRCxFQUFYLENBQVI7QUFBQSxPQUF2QixFQUpGLEtBS0ssSUFBSUwsY0FBSixFQUFvQkosTUFBTSxDQUFDVSxHQUFQLENBQVdO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bnQiOlsiLypnbG9iYWwgTXV0YXRpb25PYnNlcnZlciovXG4vKipcbiAqIGRhdGEtc3R5bGU6IGNsYXNzU3R5bGUgfCBzdHlsZSB8IGF0dHJpYnV0ZVxuICogZGF0YS1zdHlsZV9zeW5jOiBhbnkgdmFsaWQgY3NzIHByb3BlcnR5XG4gKiBkYXRhLXN0eWxlX3VuaXQ6IGFueSB2YWxpZCBjc3MgdW5pdCB0eXBlXG4gKiBkYXRhLXN0eWxlX3RhcmdldDogdW5pcXVlIGlkIG9mIGVsZW1lbnQgd3JpdHRlbiB0byBkYXRhLWVsZW1lbnRfaWRcbiAqL1xuXG4vLyB0b2RvOiBkaXNhYmxlIGlucHV0IHdoZW4gdGhlcmUgaXMgbm8gZGF0YS1zdHlsZSwgdGhlcmUgaXMgbm8gcmVhc29uIGl0IHRvIGhhdmUgZGVmYXVsdCB2YWx1ZSBpdCBzaG91bGQgYmVcbi8vIGRpc2FibGVkXG4vLyBpbXBvcnQgeyByZWZzIGFzIHBpY2tyUmVmcyB9IGZyb20gJy4uLy4uL0NvQ3JlYXRlLWJ1aWxkZXIvc3JjL3BpY2tyLmpzJztcblxuLy9kdW1teSBjaGFuZ2UgMlxubGV0IHBpY2tyUmVmcyA9IHdpbmRvdy5Db0NyZWF0ZVBpY2tyLnJlZnM7XG5cbmxldCBmaWx0ZXJzID0gW107XG5sZXQgYWxsRnJhbWVzID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBhbGxGcmFtZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gbmV3IFNldCgpO1xuICBmb3IgKGxldCBbZnJhbWVPYmplY3QsIGZyYW1lXSBvZiBhbGxGcmFtZXMpIHtcbiAgICBsZXQgY2FsbGJhY2tSZXN1bHQgPSBjYWxsYmFjayhmcmFtZS5kb2N1bWVudCwgZnJhbWUud2luZG93KTtcbiAgICBpZiAoXG4gICAgICBjYWxsYmFja1Jlc3VsdCAmJlxuICAgICAgdHlwZW9mIGNhbGxiYWNrUmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIlxuICAgIClcbiAgICAgIGNhbGxiYWNrUmVzdWx0LmZvckVhY2goKGVsKSA9PiByZXN1bHQuYWRkKGVsKSk7XG4gICAgZWxzZSBpZiAoY2FsbGJhY2tSZXN1bHQpIHJlc3VsdC5hZGQoY2FsbGJhY2tSZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KS5maWx0ZXIoXG4gICAgKGVsKSA9PiAhZmlsdGVycy5zb21lKChmaWx0ZXIpID0+IGVsLm1hdGNoZXMoZmlsdGVyKSlcbiAgKTtcbn1cblxuXG5mdW5jdGlvbiB3YXRjaElucHV0Q2hhbmdlKG11dGF0aW9uKSB7XG4gIGxldCBpbnB1dE1ldGEgPSB2YWxpZGF0ZU5ld0lucHV0KG11dGF0aW9uLnRhcmdldCk7XG4gIGlmICghaW5wdXRNZXRhKSByZXR1cm47XG5cbiAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwiZGF0YS1zdHlsZV90YXJnZXRcIikge1xuICAgIGxldCBlbGVtZW50ID0gZ2V0RWxlbWVudChpbnB1dE1ldGEuaW5wdXQpO1xuICAgIGlmIChlbGVtZW50KSB1cGRhdGVJbnB1dChlbGVtZW50LCBbaW5wdXRNZXRhLmlucHV0XSk7XG4gIH1cbiAgLy8gZWxzZSBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIC8vICAgbGV0IHsgaW5wdXQsIGRhdGFBdHRyaWJ1dGUsIGRhdGFQcm9wZXJ0eSB9ID0gaW5wdXRNZXRhO1xuICAvLyAgIGxldCBlbGVtZW50SWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlX3RhcmdldFwiKTtcbiAgLy8gICB1cGRhdGVFbGVtZW50KGlucHV0TWV0YSwgZWxlbWVudElkLCB0cnVlKTtcbiAgLy8gfVxufVxuXG4vLyBmdW5jdGlvbiB3YXRjaEVsZW1lbnRDaGFuZ2UobXV0YXRpb25zTGlzdCwgb2JzZXJ2ZXIpIHtcbi8vICAgZm9yIChsZXQgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdCkge1xuLy8gICAgIHVwZGF0ZUlucHV0KG11dGF0aW9uLnRhcmdldCk7XG4vLyAgIH1cbi8vIH1cblxuLy8gZnVuY3Rpb24gd2F0Y2hJbnB1dENoYW5nZShtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikge1xuLy8gICB3YXRjaEVsZW1lbnRDaGFuZ2VPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4vLyAgIGZvciAobGV0IG11dGF0aW9uIG9mIG11dGF0aW9uc0xpc3QpXG4vLyAgICAgaWYgKFxuLy8gICAgICAgLy8gbXV0YXRpb24udGFyZ2V0LmlzUmVhY3RpdmUgIT09IGZhbHNlICYmXG4vLyAgICAgICBtdXRhdGlvbi50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJlxuLy8gICAgICAgbXV0YXRpb24udGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5QVVRcIlxuLy8gICAgICkge1xuLy8gICAgICAgbGV0IGlucHV0TWV0YSA9IHZhbGlkYXRlTmV3SW5wdXQobXV0YXRpb24udGFyZ2V0KTtcbi8vICAgICAgIGlmICghaW5wdXRNZXRhKSByZXR1cm47XG5cbi8vICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcImRhdGEtc3R5bGVfdGFyZ2V0XCIpIHtcbi8vICAgICAgICAgbGV0IGVsZW1lbnQgPSBnZXRFbGVtZW50KGlucHV0TWV0YS5pbnB1dCk7XG4vLyAgICAgICAgIC8vIG11dGF0aW9uLnRhcmdldC5pc1JlYWN0aXZlID0gZmFsc2U7XG5cbi8vICAgICAgICAgdXBkYXRlSW5wdXQoZWxlbWVudCwgW2lucHV0TWV0YS5pbnB1dF0pO1xuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgdXBkYXRlRWxlbWVudChpbnB1dE1ldGEpO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgd2F0Y2hFbGVtZW50Q2hhbmdlT2JzZXJ2ZXIub2JzZXJ2ZShjYW52YXMsIGNvbmZpZ0VsZW1lbnQpOy8vIHRvZG86IG5vIGNhbnZhc1xuLy8gfVxuXG4vLyBjYW52YXMuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbi8vICAgdXBkYXRlSW5wdXQoZS50YXJnZXQpXG4vLyB9KTtcblxuZnVuY3Rpb24gZ2V0SW5wdXRzKGVsZW1lbnQpIHtcbiAgbGV0IGlucHV0cyA9IFtdO1xuICBsZXQgYWxsSW5wdXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpKTtcbiAgYWxsSW5wdXRzLmZvckVhY2goKGlucHV0Q2FuZGlkYXRlKSA9PiB7XG4gICAgbGV0IGlucHV0TWV0YSA9IHZhbGlkYXRlTmV3SW5wdXQoaW5wdXRDYW5kaWRhdGUpO1xuICAgIGlmICghaW5wdXRNZXRhKSByZXR1cm47XG5cbiAgICBsZXQgYWxsUmVmZXJlbmNlZEVsID0gYWxsRnJhbWUoKGZyYW1lKSA9PlxuICAgICAgZnJhbWUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgaW5wdXRNZXRhLmlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVfdGFyZ2V0XCIpXG4gICAgICApXG4gICAgKTtcbiAgICBpZiAoQXJyYXkuZnJvbShhbGxSZWZlcmVuY2VkRWwpLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4gICAgICBpbnB1dHMucHVzaChpbnB1dE1ldGEuaW5wdXQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnB1dHM7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnQoaW5wdXQpIHtcbiAgbGV0IGlkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZV90YXJnZXRcIik7XG4gIGlmIChpZCkgcmV0dXJuIGFsbEZyYW1lKChmcmFtZSkgPT4gZnJhbWUucXVlcnlTZWxlY3RvcihpZCkpWzBdO1xuICBlbHNlIHJldHVybiBmYWxzZTtcbn1cbi8vIGZ1bmN0aW9uIGdldFJlYWxTdGF0aWNDb21wU3R5bGVPbGQoZWxlbWVudCkge1xuLy8gICAvLyBjYWxjdWxhdGUgcmVhbCBjc3MgaW5zdGVhZCBvZiBjb211cHRlZCBlbGVtZW50XG4vLyAgIHdhdGNoRWxlbWVudENoYW5nZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbi8vICAgbGV0IG9sZERpc3BhbHkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG5cbi8vICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbi8vICAgbGV0IGNvbXB1dGVkU3R5bGVzTGl2ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuLy8gICBsZXQgY29tcHV0ZWRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBjb21wdXRlZFN0eWxlc0xpdmUpO1xuLy8gICBjb21wdXRlZFN0eWxlcy5kaXNwbGF5ID0gb2xkRGlzcGFseTtcblxuLy8gICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBvbGREaXNwYWx5O1xuLy8gICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSA9PSBcIlwiKSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuLy8gICB3YXRjaEVsZW1lbnRDaGFuZ2VPYnNlcnZlci5vYnNlcnZlKGNhbnZhcywgY29uZmlnRWxlbWVudCk7XG4vLyAgIHJldHVybiBjb21wdXRlZFN0eWxlcztcbi8vIH1cbi8vIGZ1bmN0aW9uIGdldEFsbFN0eWxlcygpIHtcbi8vICAgZm9yIChsZXQgc3R5bGVTaGVldCBvZiBkb2N1bWVudC5zdHlsZVNoZWV0cykge1xuLy8gICAgIGxldCBzdHlsZTtcbi8vICAgICB0cnkge1xuLy8gICAgICAgc3R5bGUgPSBzdHlsZVNoZWV0LmNzc1J1bGVzIHx8IHN0eWxlU2hlZXQucnVsZXM7XG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbi8vICAgICAgIGNvbnNvbGUubG9nKFwiY291bGRuJ3QgcGFyc2Ugc3R5bGVcIik7XG4vLyAgICAgfVxuLy8gICAgIGlmKCFzdHlsZSkgY29udGludWU7XG4vLyAgICAgICBmb3IgKGxldCBydWxlIG9mIHN0eWxlKSB7XG4vLyAgICAgICAgIGxldCBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3JUZXh0O1xuLy8gICAgICAgICBxdWVyeVNlbGVjdG9yQWxsXG4vLyAgICAgICB9XG4vLyAgICAgc3R5bGUgPSB1bmRlZmluZWQ7XG4vLyAgIH1cbi8vIH1cbi8vIGdldEFsbFN0eWxlcygpO1xubGV0IGNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0UmVhbFN0YXRpY0NvbXBTdHlsZShlbGVtZW50KSB7XG4gIGxldCBzaG91bGRDYWNoZSA9IGZhbHNlO1xuICBpZihjYWNoZS5oYXMoZWxlbWVudCkpXG4gIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICB9ZWxzZSBpZihjYWNoZS5sZW5ndGggPCAxMClcbiAge1xuICAgIHNob3VsZENhY2hlID0gdHJ1ZTtcbiAgfVxuICAvLyBjYWxjdWxhdGUgcmVhbCBjc3MgaW5zdGVhZCBvZiBjb211cHRlZCBlbGVtZW50XG4gIC8vIHdhdGNoRWxlbWVudENoYW5nZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgbGV0IG9sZERpc3BhbHkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gIC8vIGVsZW1lbnQuc2V0QXR0cmlidXRlKCduby1vYnNlcnZlJywgdHJ1ZSlcbiAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgbGV0IGNvbXB1dGVkU3R5bGVzTGl2ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBsZXQgY29tcHV0ZWRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBjb21wdXRlZFN0eWxlc0xpdmUpO1xuICBjb21wdXRlZFN0eWxlcy5kaXNwbGF5ID0gb2xkRGlzcGFseTtcblxuICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBvbGREaXNwYWx5O1xuICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSA9PSBcIlwiKSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAvLyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnbm8tb2JzZXJ2ZScpXG4gIC8vIHdhdGNoRWxlbWVudENoYW5nZU9ic2VydmVyLm9ic2VydmUoY2FudmFzLCBjb25maWdFbGVtZW50KTtcbiAgaWYoc2hvdWxkQ2FjaGUpXG4gICAgY2FjaGUuc2V0KGVsZW1lbnQsIGNvbXB1dGVkU3R5bGVzKTtcbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGVzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0lucHV0KGlucHV0KSB7XG4gIGxldCBkYXRhQXR0cmlidXRlID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZVwiKTtcbiAgaWYgKCFkYXRhQXR0cmlidXRlKSByZXR1cm47XG4gIC8vIGNvbnNvbGUud2FybihcImNjLXN0eWxlOiBpbnB1dCBkb2Vzbid0IGhhdmUgZGF0YS1zdHlsZVwiKVxuICBkYXRhQXR0cmlidXRlID0gZGF0YUF0dHJpYnV0ZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZGF0YVByb3BlcnR5ID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZV9zeW5jXCIpO1xuICBpZiAoIWRhdGFQcm9wZXJ0eSkgcmV0dXJuO1xuICAvLyBjb25zb2xlLndhcm4oXCJjYy1zdHlsZTogaW5wdXQgZG9lc24ndCBoYXZlIGRhdGEtc3R5bGVcIilcbiAgZGF0YVByb3BlcnR5ID0gZGF0YVByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB7XG4gICAgaW5wdXQsXG4gICAgZGF0YUF0dHJpYnV0ZSxcbiAgICBkYXRhUHJvcGVydHksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pdChzdHlsZSkge1xuICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlKTtcbiAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICBsZXQgdmFsdWVMZW5ndGggPSAodmFsdWUgKyBcIlwiKS5sZW5ndGg7XG4gICAgcmV0dXJuIFt2YWx1ZSwgc3R5bGUuc3Vic3RyKHZhbHVlTGVuZ3RoKSB8fCBcIm5vbmVcIl07XG4gIH1cbiAgcmV0dXJuIFtzdHlsZSwgXCJcIl07XG59XG5cbmZ1bmN0aW9uIGdldENvQ3JlYXRlU3R5bGUoY2xhc3NMaXN0KSB7XG4gIGxldCBzdHlsZXMgPSB7fTtcbiAgY2xhc3NMaXN0LmZvckVhY2goKGNsYXNzbmFtZSkgPT4ge1xuICAgIGxldCBbbmFtZSwgdmFsdWVdID0gY2xhc3NuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gcHV0Q29DcmVhdGVTdHlsZShjbGFzc0xpc3QsIG5ld1N0eWxlcykge1xuICBsZXQgc3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gIGNsYXNzTGlzdC5mb3JFYWNoKChjbGFzc25hbWUpID0+IHtcbiAgICBsZXQgW25hbWUsIHZhbHVlXSA9IGNsYXNzbmFtZS5zcGxpdChcIjpcIik7XG4gICAgc3R5bGVNYXAuc2V0KG5hbWUsIHZhbHVlKTtcbiAgfSk7XG5cbiAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhuZXdTdHlsZXMpKSB7XG4gICAgaWYgKHN0eWxlTWFwLmhhcyhuYW1lKSkge1xuICAgICAgbGV0IHZhbHVlID0gc3R5bGVNYXAuZ2V0KG5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lICsgXCI6XCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIGNsYXNzTGlzdC5hZGQobmFtZSArIFwiOlwiICsgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZWNjQ3NzU3R5bGUoY2xhc3NMaXN0LCBwcm9wZXJ0eSkge1xuICBsZXQgY29DcmVhdGVDc3MgPSBnZXRDb0NyZWF0ZVN0eWxlKGNsYXNzTGlzdCk7XG4gIGRlbGV0ZSBjb0NyZWF0ZUNzc1twcm9wZXJ0eV07XG4gIHB1dENvQ3JlYXRlU3R5bGUoY2xhc3NMaXN0LCBjb0NyZWF0ZUNzcyk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkVsZW1lbnRJZChlbGVtZW50LCBpc1JlYWN0aXZlID0gZmFsc2UpIHtcbiAgbGV0IGlucHV0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSk7XG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dENhbmRpZGF0ZSkgPT4ge1xuICAgIGxldCBpbnB1dE1ldGEgPSB2YWxpZGF0ZU5ld0lucHV0KGlucHV0Q2FuZGlkYXRlKTtcbiAgICBpZiAoIWlucHV0TWV0YSkgcmV0dXJuO1xuICAgIGxldCB7IGlucHV0LCBkYXRhQXR0cmlidXRlLCBkYXRhUHJvcGVydHkgfSA9IGlucHV0TWV0YTtcblxuICAgIGlucHV0LmlzUmVhY3RpdmUgPSBpc1JlYWN0aXZlO1xuICAgIGxldCBlbGVtZW50SWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudF9pZFwiKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGVJZkRpZmZlcihcbiAgICAgIFwiZGF0YS1zdHlsZV90YXJnZXRcIixcbiAgICAgIGBbZGF0YS1lbGVtZW50X2lkPSR7ZWxlbWVudElkfV1gXG4gICAgKTtcbiAgfSk7XG59XG5cbi8vIHBpY2tlZCB1cCBmcm9tIHN0YWNrb3ZlcmZsb3dcbmZ1bmN0aW9uIHJnYmEyaGV4KG9yaWcpIHtcbiAgbGV0IGEsIGlzUGVyY2VudCxcbiAgICByZ2IgPSBvcmlnLnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goL15yZ2JhP1xcKChcXGQrKSwoXFxkKyksKFxcZCspLD8oW14sXFxzKV0rKT8vaSksXG4gICAgYWxwaGEgPSAocmdiICYmIHJnYls0XSB8fCBcIlwiKS50cmltKCksXG4gICAgaGV4ID0gcmdiID9cbiAgICAocmdiWzFdIHwgMSA8PCA4KS50b1N0cmluZygxNikuc2xpY2UoMSkgK1xuICAgIChyZ2JbMl0gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSArXG4gICAgKHJnYlszXSB8IDEgPDwgOCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpIDogb3JpZztcblxuICBpZiAoYWxwaGEgIT09IFwiXCIpIHtcbiAgICBhID0gYWxwaGE7XG4gIH1cbiAgZWxzZSB7XG4gICAgYSA9IDE7XG4gIH1cbiAgLy8gbXVsdGlwbHkgYmVmb3JlIGNvbnZlcnQgdG8gSEVYXG4gIGEgPSAoKGEgKiAyNTUpIHwgMSA8PCA4KS50b1N0cmluZygxNikuc2xpY2UoMSlcbiAgaGV4ID0gaGV4ICsgYTtcblxuICByZXR1cm4gaGV4O1xufVxuXG4vLyBtdXRhdGlvbiByZWZsZWN0IGRhdGEtc3R5bGVfdW5pdFxuZnVuY3Rpb24gc2V0UGxhY2VIb2xkZXJzKGVsZW1lbnQpIHtcbiAgbGV0IGlucHV0cyA9IGdldElucHV0cyhlbGVtZW50KTtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0Q2FuZGlkYXRlKSA9PiB7XG4gICAgbGV0IGlucHV0TWV0YSA9IHZhbGlkYXRlTmV3SW5wdXQoaW5wdXRDYW5kaWRhdGUpO1xuICAgIGlmICghaW5wdXRNZXRhKSByZXR1cm47XG4gICAgbGV0IHsgaW5wdXQsIGRhdGFBdHRyaWJ1dGUsIGRhdGFQcm9wZXJ0eSB9ID0gaW5wdXRNZXRhO1xuICAgIGxldCBjbWxEYXRhUHJvcGVydHkgPSB0b0NhbWVsQ2FzZShkYXRhUHJvcGVydHkpO1xuICAgIGxldCBlbGVtZW50SWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudF9pZFwiKTtcbiAgICBpZiAoIWVsZW1lbnRJZCkgcmV0dXJuO1xuICAgIGxldCBpbnB1dEVsZW1lbnRJZCA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVfdGFyZ2V0XCIpO1xuICAgIGlmIChlbGVtZW50SWQgIT0gaW5wdXRFbGVtZW50SWQpIHtcbiAgICAgIGxldCBjb21wdXRlZFN0eWxlcyA9IGdldFJlYWxTdGF0aWNDb21wU3R5bGUoZWxlbWVudCk7XG4gICAgICBsZXQgc3R5bGU7XG4gICAgICBzd2l0Y2ggKGRhdGFBdHRyaWJ1dGUpIHtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgc3R5bGUgPSBjb21wdXRlZFN0eWxlc1tjbWxEYXRhUHJvcGVydHldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xhc3NzdHlsZVwiOlxuICAgICAgICAgIGxldCBjb0NyZWF0ZUNzcyA9IGdldENvQ3JlYXRlU3R5bGUoZWxlbWVudC5jbGFzc0xpc3QpO1xuICAgICAgICAgIHN0eWxlID0gY29DcmVhdGVDc3NbY21sRGF0YVByb3BlcnR5XTtcbiAgICAgICAgICBpZiAoIXN0eWxlKSBzdHlsZSA9IGNvbXB1dGVkU3R5bGVzW2NtbERhdGFQcm9wZXJ0eV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHlsZSA9IGNvbXB1dGVkU3R5bGVzW2NtbERhdGFQcm9wZXJ0eV07XG4gICAgICB9XG4gICAgICAvLyBzdHlsZT0gdHJ1ZTtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSB1bml0XG4gICAgICAvLyB0b2RvOiB3aHkgaXQncyBsb29rIGxpa2UgdXBkYXRlIGlucHV0PyBzaG91bGQgaSB1cGRhdGU/XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgbGV0IFt2YWx1ZSwgdW5pdF0gPSBwYXJzZVVuaXQoc3R5bGUpO1xuXG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgLy8gQ29DcmVhdGUucmVwbGFjZURhdGFDcmR0KHtcbiAgICAgICAgICAgIC8vICAgY29sbGVjdGlvbjogJ2J1aWxkZXInLFxuICAgICAgICAgICAgLy8gICBkb2N1bWVudF9pZDogJ251bGwnLFxuICAgICAgICAgICAgLy8gICBuYW1lOiBpbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcbiAgICAgICAgICAgIC8vICAgdmFsdWU6IHZhbHVlICsgJycsXG4gICAgICAgICAgICAvLyAgIHBvc2l0aW9uOiAnMCcsXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSByZ2JhMmhleCh2YWx1ZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBDb0NyZWF0ZS5yZXBsYWNlRGF0YUNyZHQoe1xuICAgICAgICAgICAgLy8gICBjb2xsZWN0aW9uOiAnYnVpbGRlcicsXG4gICAgICAgICAgICAvLyAgIGRvY3VtZW50X2lkOiAnbnVsbCcsXG4gICAgICAgICAgICAvLyAgIG5hbWU6IGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgICAgLy8gICB2YWx1ZTogdmFsdWUgKyAnJyxcbiAgICAgICAgICAgIC8vICAgcG9zaXRpb246ICcwJyxcbiAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlICsgJyc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZUlmRGlmZmVyKFwiZGF0YS1zdHlsZV91bml0XCIsIHVuaXQgfHwgJycpO1xuICAgICAgfVxuXG4gICAgfVxuICB9KTtcbn1cblxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUlucHV0KGVsZW1lbnQsIGlucHV0cykge1xuICBsZXQgY29tcHV0ZWRTdHlsZXMgPSBnZXRSZWFsU3RhdGljQ29tcFN0eWxlKGVsZW1lbnQpO1xuICAvLyBsZXQgY29tcHV0ZWRTdHlsZXMgPSB7fTtcbiAgaWYgKCFpbnB1dHMpIGlucHV0cyA9IGdldElucHV0cyhlbGVtZW50KTtcblxuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXRDYW5kaWRhdGUpID0+IHtcbiAgICBsZXQgaW5wdXRNZXRhID0gdmFsaWRhdGVOZXdJbnB1dChpbnB1dENhbmRpZGF0ZSk7XG4gICAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcbiAgICBsZXQgeyBpbnB1dCwgZGF0YUF0dHJpYnV0ZSwgZGF0YVByb3BlcnR5IH0gPSBpbnB1dE1ldGE7XG4gICAgbGV0IGNtbERhdGFQcm9wZXJ0eSA9IHRvQ2FtZWxDYXNlKGRhdGFQcm9wZXJ0eSk7XG4gICAgbGV0IGVsZW1lbnRJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50X2lkXCIpO1xuICAgIGlmICghZWxlbWVudElkKSByZXR1cm47XG5cbiAgICAvL2NhbGN1bGF0ZSBzdHlsZVxuICAgIGxldCBzdHlsZTtcbiAgICBzd2l0Y2ggKGRhdGFBdHRyaWJ1dGUpIHtcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBzdHlsZSA9IGNvbXB1dGVkU3R5bGVzW2NtbERhdGFQcm9wZXJ0eV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsYXNzc3R5bGVcIjpcbiAgICAgICAgbGV0IGNvQ3JlYXRlQ3NzID0gZ2V0Q29DcmVhdGVTdHlsZShlbGVtZW50LmNsYXNzTGlzdCk7XG4gICAgICAgIHN0eWxlID0gY29DcmVhdGVDc3NbY21sRGF0YVByb3BlcnR5XTtcbiAgICAgICAgaWYgKCFzdHlsZSkgc3R5bGUgPSBjb21wdXRlZFN0eWxlc1tjbWxEYXRhUHJvcGVydHldO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3R5bGUgPSBjb21wdXRlZFN0eWxlc1tjbWxEYXRhUHJvcGVydHldO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBzdHlsZSB1bml0XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBsZXQgW3ZhbHVlLCB1bml0XSA9IHBhcnNlVW5pdChzdHlsZSk7XG5cbiAgICAgIGlmIChpbnB1dE1ldGEuaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwaWNrcicpKSB7XG4gICAgICAgIGlmICghcGlja3JSZWZzLmhhcyhpbnB1dCkpIHJldHVybjtcbiAgICAgICAgbGV0IHBpY2tySW5zID0gcGlja3JSZWZzLmdldChpbnB1dCk7XG4gICAgICAgIHdpbmRvdy5Db0NyZWF0ZVBpY2tyLmRpc2FibGVkRXZlbnQgPSB0cnVlO1xuICAgICAgICBwaWNrcklucy5zZXRDb2xvcihzdHlsZSk7XG4gICAgICAgIHdpbmRvdy5Db0NyZWF0ZVBpY2tyLmRpc2FibGVkRXZlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgLy8gQ29DcmVhdGUucmVwbGFjZURhdGFDcmR0KHtcbiAgICAgICAgICAgIC8vICAgY29sbGVjdGlvbjogJ2J1aWxkZXInLFxuICAgICAgICAgICAgLy8gICBkb2N1bWVudF9pZDogJ251bGwnLFxuICAgICAgICAgICAgLy8gICBuYW1lOiBpbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcbiAgICAgICAgICAgIC8vICAgdmFsdWU6IHZhbHVlICsgJycsXG4gICAgICAgICAgICAvLyAgIHBvc2l0aW9uOiAnMCcsXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSByZ2JhMmhleCh2YWx1ZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBDb0NyZWF0ZS5yZXBsYWNlRGF0YUNyZHQoe1xuICAgICAgICAgICAgLy8gICBjb2xsZWN0aW9uOiAnYnVpbGRlcicsXG4gICAgICAgICAgICAvLyAgIGRvY3VtZW50X2lkOiAnbnVsbCcsXG4gICAgICAgICAgICAvLyAgIG5hbWU6IGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgICAgLy8gICB2YWx1ZTogdmFsdWUgKyAnJyxcbiAgICAgICAgICAgIC8vICAgcG9zaXRpb246ICcwJyxcbiAgICAgICAgICAgIC8vIH0pXG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSArICcnOyAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cblxuXG5cblxuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlSWZEaWZmZXIoXCJkYXRhLXN0eWxlX3VuaXRcIiwgdW5pdCB8fCAnJyk7XG4gICAgfVxuXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50VmFsdWUodmFsdWUsIGRhdGFBdHRyaWJ1dGUsIGRhdGFQcm9wZXJ0eSwgZWxlbWVudElkKXtcbiAgbGV0IGVsZW1lbnQgPSBhbGxGcmFtZSgoZnJhbWUpID0+IGZyYW1lLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudElkKSlbMF07XG4gIGxldCBjYW1lbERhdGFQcm9wZXJ0eSA9IHRvQ2FtZWxDYXNlKGRhdGFQcm9wZXJ0eSk7XG4gICBzd2l0Y2ggKGRhdGFBdHRyaWJ1dGUpIHtcbiAgICAgIGNhc2UgXCJjbGFzc3N0eWxlXCI6XG4gICAgICAgIGVsZW1lbnQuc2V0Q0NTdHlsZShkYXRhUHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgZWxlbWVudC5zZXRTdGx5ZUlmRGlmZmVyKGNhbWVsRGF0YVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBjb2RlXG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRWxlbWVudChpbnB1dE1ldGEsIGVsZW1lbnRJZCwgaXNDb2xsKSB7XG4gIGxldCBlbGVtZW50ID0gYWxsRnJhbWUoKGZyYW1lKSA9PiBmcmFtZS5xdWVyeVNlbGVjdG9yKGVsZW1lbnRJZCkpWzBdO1xuXG4gIGxldCB7IGlucHV0LCBkYXRhUHJvcGVydHksIGRhdGFBdHRyaWJ1dGUgfSA9IGlucHV0TWV0YTtcbiAgbGV0IGNhbWVsRGF0YVByb3BlcnR5ID0gdG9DYW1lbENhc2UoZGF0YVByb3BlcnR5KTtcbiAgbGV0IHN0eWxlO1xuXG4gIGlmIChpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJ3BpY2tyJykpIHtcbiAgICBpZiAoIXBpY2tyUmVmcy5oYXMoaW5wdXQpKSByZXR1cm47XG4gICAgbGV0IHBpY2tySW5zID0gcGlja3JSZWZzLmdldChpbnB1dCk7XG4gICAgc3R5bGUgPSBwaWNrcklucy5nZXRDb2xvcigpLnRvSEVYQSgpLnRvU3RyaW5nKCk7XG4gICAgc3dpdGNoIChkYXRhQXR0cmlidXRlKSB7XG4gICAgICBjYXNlIFwiY2xhc3NzdHlsZVwiOlxuICAgICAgICBlbGVtZW50LnNldENDU3R5bGUoZGF0YVByb3BlcnR5LCBzdHlsZSk7XG4gICAgICAgIGlzQ29sbCAmJlxuICAgICAgICAgIGNvbGxhYm9yYXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBzdHlsZSxcbiAgICAgICAgICAgIHVuaXQ6ICcnLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBkYXRhUHJvcGVydHksXG4gICAgICAgICAgICBkYXRhQXR0cmlidXRlLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnRJZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgZWxlbWVudC5zZXRTdGx5ZUlmRGlmZmVyKGNhbWVsRGF0YVByb3BlcnR5LCBzdHlsZSkgJiZcbiAgICAgICAgICBpc0NvbGwgJiZcbiAgICAgICAgICBjb2xsYWJvcmF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogc3R5bGUsXG4gICAgICAgICAgICB1bml0OiAnJyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgZGF0YVByb3BlcnR5LFxuICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZSxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50SWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBjb2RlXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGxldCBbdmFsdWUsIHVuaXRdID0gcGFyc2VVbml0KGlucHV0LnZhbHVlKTtcblxuICAgIHVuaXQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlX3VuaXRcIik7XG4gICAgc3dpdGNoIChkYXRhQXR0cmlidXRlKSB7XG4gICAgICBjYXNlIFwiY2xhc3NzdHlsZVwiOlxuICAgICAgICAvLyB3aGVuIGlucHV0IGlzIGVtcHR5IHJlbW92ZSB0aGF0IHN0eWxlXG4gICAgICAgIGlmICghaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICByZW1vdmVjY0Nzc1N0eWxlKGVsZW1lbnQuY2xhc3NMaXN0LCBkYXRhUHJvcGVydHkpO1xuICAgICAgICAgIGlzQ29sbCAmJlxuICAgICAgICAgICAgY29sbGFib3JhdGUoe1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGRhdGFQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgZWxlbWVudElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gdGhlcmUgaXMgc3R5bGUgc2V0IHRoYXRcblxuICAgICAgICBzdHlsZSA9IHZhbHVlICsgdW5pdDtcbiAgICAgICAgZWxlbWVudC5zZXRDQ1N0eWxlKGRhdGFQcm9wZXJ0eSwgc3R5bGUpO1xuICAgICAgICBpc0NvbGwgJiZcbiAgICAgICAgICBjb2xsYWJvcmF0ZSh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGRhdGFQcm9wZXJ0eSxcbiAgICAgICAgICAgIGRhdGFBdHRyaWJ1dGUsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudElkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG5cbiAgICAgICAgLy8gbGV0IGNvbXB1dGVkU3R5bGVzID0gZ2V0UmVhbFN0YXRpY0NvbXBTdHlsZShlbGVtZW50KTtcbiAgICAgICAgLy8gbGV0IHN0eWxlVmFsdWUgPSBjb21wdXRlZFN0eWxlc1tkYXRhUHJvcGVydHldO1xuICAgICAgICBpZiAoIWlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRTdGx5ZUlmRGlmZmVyKGNhbWVsRGF0YVByb3BlcnR5LCBcIlwiKSAmJlxuICAgICAgICAgICAgaXNDb2xsICYmXG4gICAgICAgICAgICBjb2xsYWJvcmF0ZSh7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgZGF0YVByb3BlcnR5LFxuICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlLFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBlbGVtZW50SWQsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGVsZW1lbnQuc3R5bGVbZGF0YVByb3BlcnR5XSA9IFwiXCI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUgPSB2YWx1ZSArIHVuaXQ7XG4gICAgICAgIGVsZW1lbnQuc2V0U3RseWVJZkRpZmZlcihjYW1lbERhdGFQcm9wZXJ0eSwgc3R5bGUpICYmXG4gICAgICAgICAgaXNDb2xsICYmXG4gICAgICAgICAgY29sbGFib3JhdGUoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB1bml0LFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBkYXRhUHJvcGVydHksXG4gICAgICAgICAgICBkYXRhQXR0cmlidXRlLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnRJZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gZWxlbWVudC5zdHlsZVtkYXRhUHJvcGVydHldID0gc3R5bGU7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICBsZXQgaW5kZXggPSAwO1xuICBkbyB7XG4gICAgaW5kZXggPSBzdHIuaW5kZXhPZihcIi1cIiwgaW5kZXgpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGxldCB0ID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKSAtIDMyKTtcbiAgICAgIHQgKz0gc3RyLnN1YnN0cihpbmRleCArIDIpO1xuICAgICAgc3RyID0gdDtcbiAgICB9XG4gICAgZWxzZSBicmVhaztcbiAgfSB3aGlsZSAodHJ1ZSk7XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZUlmRGlmZmVyKHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUocHJvcGVydHkpICE9PSB2YWx1ZSlcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzZXRTdGx5ZUlmRGlmZmVyKHByb3BlcnR5LCB2YWx1ZSkge1xuICBsZXQgY29tcHV0ZWRTdHlsZXMgPSBnZXRSZWFsU3RhdGljQ29tcFN0eWxlKHRoaXMpO1xuICBpZiAoY29tcHV0ZWRTdHlsZXNbcHJvcGVydHldICE9PSB2YWx1ZSkge1xuICAgIHRoaXMuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzSWZEaWZmZXIoY2xhc3NOYW1lKSB7XG4gIGlmICghdGhpcy5jbGFzc0xpc3QuaGFzKGNsYXNzTmFtZSkpIHRoaXMuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xufVxuXG5mdW5jdGlvbiBzZXRDQ1N0eWxlKHByb3BlcnR5LCBuZXdWYWx1ZSkge1xuICBmb3IgKGxldCBjbGFzc25hbWUgb2YgdGhpcy5jbGFzc0xpc3QpIHtcbiAgICBsZXQgW25hbWUsIHZhbHVlXSA9IGNsYXNzbmFtZS5zcGxpdChcIjpcIik7XG4gICAgaWYgKG5hbWUgPT09IHByb3BlcnR5KSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5yZXBsYWNlKGNsYXNzbmFtZSwgcHJvcGVydHkgKyBcIjpcIiArIG5ld1ZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNsYXNzTGlzdC5hZGQocHJvcGVydHkgKyBcIjpcIiArIG5ld1ZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q0NTdHlsZShwcm9wZXJ0eSkge1xuICBsZXQgc3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gIGZvciAobGV0IGNsYXNzbmFtZSBvZiB0aGlzLmNsYXNzTGlzdCkge1xuICAgIGxldCBbbmFtZSwgdmFsdWVdID0gY2xhc3NuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBpZiAobmFtZSA9PT0gcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmxldCB0b29scyA9IHt9O1xuXG5mdW5jdGlvbiBpbml0KHsgd2luZG93T2JqZWN0LCBkb2NPYmplY3QsIGlzSWZyYW1lLCBmcmFtZSwgb25Db2xsYWJvcmF0aW9uIH0pIHtcbiAgbGV0IHJlZjtcbiAgdG9vbHMub25Db2xsYWJvcmF0aW9uID0gb25Db2xsYWJvcmF0aW9uO1xuICBpZiAoaXNJZnJhbWUpIHtcbiAgICBsZXQgZnJhbWVXaW5kb3cgPSBmcmFtZS5jb250ZW50V2luZG93O1xuICAgIGxldCBmcmFtZURvY3VtZW50ID0gZnJhbWVXaW5kb3cuZG9jdW1lbnQgfHwgZnJhbWUuY29udGVudERvY3VtZW50O1xuXG4gICAgcmVmID0ge1xuICAgICAgZnJhbWUsXG4gICAgICB3aW5kb3c6IGZyYW1lV2luZG93LFxuICAgICAgZG9jdW1lbnQ6IGZyYW1lRG9jdW1lbnQsXG4gICAgICBpc0lmcmFtZTogdHJ1ZSxcbiAgICB9O1xuICAgIGFsbEZyYW1lcy5zZXQoZnJhbWUsIHJlZik7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVmID0geyB3aW5kb3c6IHdpbmRvd09iamVjdCwgZG9jdW1lbnQ6IGRvY09iamVjdCwgaXNJZnJhbWU6IGZhbHNlIH07XG4gICAgYWxsRnJhbWVzLnNldChcIm1haW5cIiwgcmVmKTtcbiAgfVxuXG4gIHJlZi53aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZUlmRGlmZmVyID0gc2V0QXR0cmlidXRlSWZEaWZmZXI7XG4gIHJlZi53aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLnNldFN0bHllSWZEaWZmZXIgPSBzZXRTdGx5ZUlmRGlmZmVyO1xuICByZWYud2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzc0lmRGlmZmVyID0gYWRkQ2xhc3NJZkRpZmZlcjtcbiAgcmVmLndpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0Q0NTdHlsZSA9IHNldENDU3R5bGU7XG4gIHJlZi53aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldENDU3R5bGUgPSBnZXRDQ1N0eWxlO1xuXG4gIHJlZi53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgIHJlZi53aW5kb3cuQ29DcmVhdGVPYnNlcnZlci5hZGQoe1xuICAgICAgbmFtZTogXCJjY1N0eWxlXCIsXG4gICAgICBvYnNlcnZlOiBbXCJhdHRyaWJ1dGVzXCJdLFxuICAgICAgYXR0cmlidXRlczogW1wiZGF0YS1zdHlsZV90YXJnZXRcIiwgXCJ2YWx1ZVwiXSxcbiAgICAgIGluY2x1ZGU6IFwiSU5QVVQsIC5waWNrclwiLFxuICAgICAgdGFzazogd2F0Y2hJbnB1dENoYW5nZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmVmLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0O1xuXG4gICAgLy8gaW5wdXQuaXNSZWFjdGl2ZSA9IHRydWU7XG4gICAgbGV0IGlucHV0TWV0YSA9IHZhbGlkYXRlTmV3SW5wdXQoaW5wdXQpO1xuICAgIGlmICghaW5wdXRNZXRhKSByZXR1cm47XG5cbiAgICBsZXQgZWxlbWVudElkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZV90YXJnZXRcIik7XG4gICAgdXBkYXRlRWxlbWVudChpbnB1dE1ldGEsIGVsZW1lbnRJZCwgdHJ1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRGaWx0ZXIoc2VsZWN0b3IpIHtcbiAgZmlsdGVycy5wdXNoKHNlbGVjdG9yKTtcbn1cbndpbmRvdy5jY1N0eWxlID0geyBpbml0LCBhZGRGaWx0ZXIgfTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgd2luZG93LkNvQ3JlYXRlT2JzZXJ2ZXIuYWRkKHtcbiAgICBuYW1lOiBcImNjU3R5bGVcIixcbiAgICBvYnNlcnZlOiBbXCJhdHRyaWJ1dGVzXCJdLFxuICAgIGF0dHJpYnV0ZXM6IFtcImRhdGEtc3R5bGVfdGFyZ2V0XCIsIFwidmFsdWVcIl0sXG4gICAgaW5jbHVkZTogXCJJTlBVVCwgLnBpY2tyXCIsXG4gICAgdGFzazogd2F0Y2hJbnB1dENoYW5nZSxcbiAgfSk7XG5cbiAgaW5pdCh7IHdpbmRvd09iamVjdDogd2luZG93LCBkb2NPYmplY3Q6IGRvY3VtZW50IH0pO1xufSk7XG5cbkNvQ3JlYXRlU29ja2V0Lmxpc3RlbihcImNjU3R5bGVcIiwgZnVuY3Rpb24oe1xuICB2YWx1ZSxcbiAgZGF0YUF0dHJpYnV0ZSxcbiAgZGF0YVByb3BlcnR5LFxuICBlbGVtZW50SWQsXG4gIHVuaXRcbn0pIHtcbiAgbGV0IGlucHV0cyA9IGFsbEZyYW1lKChmcmFtZSkgPT5cbiAgICBmcmFtZS5xdWVyeVNlbGVjdG9yKFxuICAgICAgYFtkYXRhLXN0eWxlPSR7ZGF0YUF0dHJpYnV0ZX1dW2RhdGEtc3R5bGVfc3luYz0ke2RhdGFQcm9wZXJ0eX1dYFxuICAgIClcbiAgKTtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgdXBkYXRlRWxlbWVudFZhbHVlKHZhbHVlICsgdW5pdCwgZGF0YUF0dHJpYnV0ZSwgZGF0YVByb3BlcnR5LCBlbGVtZW50SWQpO1xuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBjb2xsYWJvcmF0ZSh7XG4gIHZhbHVlLFxuICBpbnB1dCxcbiAgZGF0YVByb3BlcnR5LFxuICBkYXRhQXR0cmlidXRlLFxuICBlbGVtZW50SWQsXG4gIGVsZW1lbnQsXG4gIHVuaXQsXG59KSB7XG4gIC8vIGlmICh2YWx1ZSAhPSBpbnB1dC52YWx1ZSkgcmV0dXJuO1xuXG4gIHRvb2xzLm9uQ29sbGFib3JhdGlvbih7XG4gICAgdmFsdWUsXG4gICAgdW5pdCxcbiAgICBkYXRhUHJvcGVydHksXG4gICAgZGF0YUF0dHJpYnV0ZSxcbiAgICBlbGVtZW50LFxuICB9KTtcblxuICBDb0NyZWF0ZS5zZW5kTWVzc2FnZSh7XG4gICAgYnJvYWRjYXN0X3NlbmRlcjogZmFsc2UsXG4gICAgcm9vbXM6IFwiXCIsXG4gICAgZW1pdDoge1xuICAgICAgbWVzc2FnZTogXCJjY1N0eWxlXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB1bml0LFxuICAgICAgICBkYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFBdHRyaWJ1dGUsXG4gICAgICAgIGVsZW1lbnRJZCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/CoCreate-styles.js\n");

/***/ })

/******/ });