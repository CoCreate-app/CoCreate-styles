/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CoCreateSelected"] = factory();
	else
		root["CoCreateSelected"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/CoCreate-styles.js":
/*!********************************!*\
  !*** ./src/CoCreate-styles.js ***!
  \********************************/
/***/ (() => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*global MutationObserver*/\n\n/**\n * data-style: classStyle | style | attribute\n * data-style_sync: any valid css property\n * data-style_unit: any valid css unit type\n * data-style_target: unique id of element written to data-element_id\n */\n// todo: disable input when there is no data-style, there is no reason it to have default value it should be\n// disabled\n// import { refs as pickrRefs } from '../../CoCreate-builder/src/pickr.js';\n//dummy change 2\nvar pickrRefs = window.CoCreatePickr.refs;\nvar filters = [];\nvar allFrames = new Map();\n\nfunction allFrame(callback) {\n  var result = new Set();\n\n  var _iterator = _createForOfIteratorHelper(allFrames),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          frameObject = _step$value[0],\n          frame = _step$value[1];\n\n      var callbackResult = callback(frame.document, frame.window);\n      if (callbackResult && typeof callbackResult[Symbol.iterator] === \"function\") callbackResult.forEach(function (el) {\n        return result.add(el);\n      });else if (callbackResult) result.add(callbackResult);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Array.from(result).filter(function (el) {\n    return !filters.some(function (filter) {\n      return el.matches(filter);\n    });\n  });\n}\n\nfunction watchInputChange(mutation) {\n  var inputMeta = validateNewInput(mutation.target);\n  if (!inputMeta) return;\n\n  if (mutation.attributeName === \"data-style_target\") {\n    var element = getElement(inputMeta.input);\n    if (element) updateInput(element, [inputMeta.input]);\n  } // else if (mutation.attributeName === \"value\") {\n  //   let { input, dataAttribute, dataProperty } = inputMeta;\n  //   let elementId = input.getAttribute(\"data-style_target\");\n  //   updateElement(inputMeta, elementId, true);\n  // }\n\n} // function watchElementChange(mutationsList, observer) {\n//   for (let mutation of mutationsList) {\n//     updateInput(mutation.target);\n//   }\n// }\n// function watchInputChange(mutationsList, observer) {\n//   watchElementChangeObserver.disconnect();\n//   for (let mutation of mutationsList)\n//     if (\n//       // mutation.target.isReactive !== false &&\n//       mutation.type === \"attributes\" &&\n//       mutation.target.tagName === \"INPUT\"\n//     ) {\n//       let inputMeta = validateNewInput(mutation.target);\n//       if (!inputMeta) return;\n//       if (mutation.attributeName === \"data-style_target\") {\n//         let element = getElement(inputMeta.input);\n//         // mutation.target.isReactive = false;\n//         updateInput(element, [inputMeta.input]);\n//       } else {\n//         updateElement(inputMeta);\n//       }\n//     }\n//   watchElementChangeObserver.observe(canvas, configElement);// todo: no canvas\n// }\n// canvas.body.addEventListener(\"click\", (e) => {\n//   updateInput(e.target)\n// });\n\n\nfunction getInputs(element) {\n  var inputs = [];\n  var allInputs = Array.from(document.getElementsByTagName(\"input\"));\n  allInputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var allReferencedEl = allFrame(function (frame) {\n      return frame.querySelectorAll(inputMeta.input.getAttribute(\"data-style_target\"));\n    });\n\n    if (Array.from(allReferencedEl).includes(element)) {\n      inputs.push(inputMeta.input);\n    }\n  });\n  return inputs;\n}\n\nfunction getElement(input) {\n  var id = input.getAttribute(\"data-style_target\");\n  if (id) return allFrame(function (frame) {\n    return frame.querySelector(id);\n  })[0];else return false;\n} // function getRealStaticCompStyleOld(element) {\n//   // calculate real css instead of comupted element\n//   watchElementChangeObserver.disconnect();\n//   let oldDispaly = element.style.display;\n//   element.style.display = \"none\";\n//   let computedStylesLive = window.getComputedStyle(element);\n//   let computedStyles = Object.assign({}, computedStylesLive);\n//   computedStyles.display = oldDispaly;\n//   element.style.display = oldDispaly;\n//   if (element.getAttribute(\"style\") == \"\") element.removeAttribute(\"style\");\n//   watchElementChangeObserver.observe(canvas, configElement);\n//   return computedStyles;\n// }\n// function getAllStyles() {\n//   for (let styleSheet of document.styleSheets) {\n//     let style;\n//     try {\n//       style = styleSheet.cssRules || styleSheet.rules;\n//     } catch (error) {\n//       console.log(\"couldn't parse style\");\n//     }\n//     if(!style) continue;\n//       for (let rule of style) {\n//         let selector = rule.selectorText;\n//         querySelectorAll\n//       }\n//     style = undefined;\n//   }\n// }\n// getAllStyles();\n\n\nvar cache = new Map();\n\nfunction getRealStaticCompStyle(element) {\n  var shouldCache = false;\n\n  if (cache.has(element)) {\n    return cache.get(element);\n  } else if (cache.length < 10) {\n    shouldCache = true;\n  } // calculate real css instead of comupted element\n  // watchElementChangeObserver.disconnect();\n\n\n  var oldDispaly = element.style.display; // element.setAttribute('no-observe', true)\n\n  element.style.display = \"none\";\n  var computedStylesLive = window.getComputedStyle(element);\n  var computedStyles = Object.assign({}, computedStylesLive);\n  computedStyles.display = oldDispaly;\n  element.style.display = oldDispaly;\n  if (element.getAttribute(\"style\") == \"\") element.removeAttribute(\"style\"); // element.removeAttribute('no-observe')\n  // watchElementChangeObserver.observe(canvas, configElement);\n\n  if (shouldCache) cache.set(element, computedStyles);\n  return computedStyles;\n}\n\nfunction validateNewInput(input) {\n  var dataAttribute = input.getAttribute(\"data-style\");\n  if (!dataAttribute) return; // console.warn(\"cc-style: input doesn't have data-style\")\n\n  dataAttribute = dataAttribute.toLowerCase();\n  var dataProperty = input.getAttribute(\"data-style_sync\");\n  if (!dataProperty) return; // console.warn(\"cc-style: input doesn't have data-style\")\n\n  dataProperty = dataProperty.toLowerCase();\n  return {\n    input: input,\n    dataAttribute: dataAttribute,\n    dataProperty: dataProperty\n  };\n}\n\nfunction parseUnit(style) {\n  var value = parseFloat(style);\n\n  if (!isNaN(value)) {\n    var valueLength = (value + \"\").length;\n    return [value, style.substr(valueLength) || \"none\"];\n  }\n\n  return [style, \"\"];\n}\n\nfunction getCoCreateStyle(classList) {\n  var styles = {};\n  classList.forEach(function (classname) {\n    var _classname$split = classname.split(\":\"),\n        _classname$split2 = _slicedToArray(_classname$split, 2),\n        name = _classname$split2[0],\n        value = _classname$split2[1];\n\n    styles[name] = value;\n  });\n  return styles;\n}\n\nfunction putCoCreateStyle(classList, newStyles) {\n  var styleMap = new Map();\n  classList.forEach(function (classname) {\n    var _classname$split3 = classname.split(\":\"),\n        _classname$split4 = _slicedToArray(_classname$split3, 2),\n        name = _classname$split4[0],\n        value = _classname$split4[1];\n\n    styleMap.set(name, value);\n  });\n\n  for (var _i2 = 0, _Object$entries = Object.entries(newStyles); _i2 < _Object$entries.length; _i2++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n        name = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (styleMap.has(name)) {\n      var _value = styleMap.get(name);\n\n      classList.remove(name + \":\" + _value);\n    }\n\n    classList.add(name + \":\" + value);\n  }\n}\n\nfunction removeccCssStyle(classList, property) {\n  var coCreateCss = getCoCreateStyle(classList);\n  delete coCreateCss[property];\n  putCoCreateStyle(classList, coCreateCss);\n}\n\nfunction assignElementId(element) {\n  var isReactive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var inputs = Array.from(document.getElementsByTagName(\"input\"));\n  inputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var input = inputMeta.input,\n        dataAttribute = inputMeta.dataAttribute,\n        dataProperty = inputMeta.dataProperty;\n    input.isReactive = isReactive;\n    var elementId = element.getAttribute(\"data-element_id\");\n    input.setAttributeIfDiffer(\"data-style_target\", \"[data-element_id=\".concat(elementId, \"]\"));\n  });\n} // picked up from stackoverflow\n\n\nfunction rgba2hex(orig) {\n  var a,\n      isPercent,\n      rgb = orig.replace(/\\s/g, '').match(/^rgba?\\((\\d+),(\\d+),(\\d+),?([^,\\s)]+)?/i),\n      alpha = (rgb && rgb[4] || \"\").trim(),\n      hex = rgb ? (rgb[1] | 1 << 8).toString(16).slice(1) + (rgb[2] | 1 << 8).toString(16).slice(1) + (rgb[3] | 1 << 8).toString(16).slice(1) : orig;\n\n  if (alpha !== \"\") {\n    a = alpha;\n  } else {\n    a = 1;\n  } // multiply before convert to HEX\n\n\n  a = (a * 255 | 1 << 8).toString(16).slice(1);\n  hex = hex + a;\n  return hex;\n} // mutation reflect data-style_unit\n\n\nfunction setPlaceHolders(element) {\n  var inputs = getInputs(element);\n  inputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var input = inputMeta.input,\n        dataAttribute = inputMeta.dataAttribute,\n        dataProperty = inputMeta.dataProperty;\n    var cmlDataProperty = toCamelCase(dataProperty);\n    var elementId = element.getAttribute(\"data-element_id\");\n    if (!elementId) return;\n    var inputElementId = input.getAttribute(\"data-style_target\");\n\n    if (elementId != inputElementId) {\n      var computedStyles = getRealStaticCompStyle(element);\n      var style;\n\n      switch (dataAttribute) {\n        case \"style\":\n          style = computedStyles[cmlDataProperty];\n          break;\n\n        case \"classstyle\":\n          var coCreateCss = getCoCreateStyle(element.classList);\n          style = coCreateCss[cmlDataProperty];\n          if (!style) style = computedStyles[cmlDataProperty];\n          break;\n\n        default:\n          style = computedStyles[cmlDataProperty];\n      } // style= true;\n      // update style unit\n      // todo: why it's look like update input? should i update?\n\n\n      if (style) {\n        var _parseUnit = parseUnit(style),\n            _parseUnit2 = _slicedToArray(_parseUnit, 2),\n            value = _parseUnit2[0],\n            unit = _parseUnit2[1];\n\n        switch (input.type) {\n          case 'file':\n            break;\n\n          case 'color':\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = rgba2hex(value);\n            break;\n\n          default:\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = value + '';\n        }\n\n        input.setAttributeIfDiffer(\"data-style_unit\", unit || '');\n      }\n    }\n  });\n}\n\nfunction updateInput(element, inputs) {\n  var computedStyles = getRealStaticCompStyle(element); // let computedStyles = {};\n\n  if (!inputs) inputs = getInputs(element);\n  inputs.forEach(function (inputCandidate) {\n    var inputMeta = validateNewInput(inputCandidate);\n    if (!inputMeta) return;\n    var input = inputMeta.input,\n        dataAttribute = inputMeta.dataAttribute,\n        dataProperty = inputMeta.dataProperty;\n    var cmlDataProperty = toCamelCase(dataProperty);\n    var elementId = element.getAttribute(\"data-element_id\");\n    if (!elementId) return; //calculate style\n\n    var style;\n\n    switch (dataAttribute) {\n      case \"style\":\n        style = computedStyles[cmlDataProperty];\n        break;\n\n      case \"classstyle\":\n        var coCreateCss = getCoCreateStyle(element.classList);\n        style = coCreateCss[cmlDataProperty];\n        if (!style) style = computedStyles[cmlDataProperty];\n        break;\n\n      default:\n        style = computedStyles[cmlDataProperty];\n    } // update style unit\n\n\n    if (style) {\n      var _parseUnit3 = parseUnit(style),\n          _parseUnit4 = _slicedToArray(_parseUnit3, 2),\n          value = _parseUnit4[0],\n          unit = _parseUnit4[1];\n\n      if (inputMeta.input.classList.contains('pickr')) {\n        if (!pickrRefs.has(input)) return;\n        var pickrIns = pickrRefs.get(input);\n        window.CoCreatePickr.disabledEvent = true;\n        pickrIns.setColor(style);\n        window.CoCreatePickr.disabledEvent = false;\n      } else {\n        switch (input.type) {\n          case 'file':\n            break;\n\n          case 'color':\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = rgba2hex(value);\n            break;\n\n          default:\n            // CoCreate.replaceDataCrdt({\n            //   collection: 'builder',\n            //   document_id: 'null',\n            //   name: input.getAttribute('name'),\n            //   value: value + '',\n            //   position: '0',\n            // })\n            input.value = value + '';\n        }\n      }\n\n      input.setAttributeIfDiffer(\"data-style_unit\", unit || '');\n    }\n  });\n}\n\nfunction updateElementValue(value, dataAttribute, dataProperty, elementId) {\n  var element = allFrame(function (frame) {\n    return frame.querySelector(elementId);\n  })[0];\n  var camelDataProperty = toCamelCase(dataProperty);\n\n  switch (dataAttribute) {\n    case \"classstyle\":\n      element.setCCStyle(dataProperty, value);\n      break;\n\n    case \"style\":\n      element.setStlyeIfDiffer(camelDataProperty, value);\n      break;\n\n    default: // code\n\n  }\n}\n\nfunction updateElement(inputMeta, elementId, isColl) {\n  var element = allFrame(function (frame) {\n    return frame.querySelector(elementId);\n  })[0];\n  var input = inputMeta.input,\n      dataProperty = inputMeta.dataProperty,\n      dataAttribute = inputMeta.dataAttribute;\n  var camelDataProperty = toCamelCase(dataProperty);\n  var style;\n\n  if (input.classList.contains('pickr')) {\n    if (!pickrRefs.has(input)) return;\n    var pickrIns = pickrRefs.get(input);\n    style = pickrIns.getColor().toHEXA().toString();\n\n    switch (dataAttribute) {\n      case \"classstyle\":\n        element.setCCStyle(dataProperty, style);\n        isColl && collaborate({\n          value: style,\n          unit: '',\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        });\n        break;\n\n      case \"style\":\n        element.setStlyeIfDiffer(camelDataProperty, style) && isColl && collaborate({\n          value: style,\n          unit: '',\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        });\n        break;\n\n      default: // code\n\n    }\n  } else {\n    var _parseUnit5 = parseUnit(input.value),\n        _parseUnit6 = _slicedToArray(_parseUnit5, 2),\n        value = _parseUnit6[0],\n        unit = _parseUnit6[1];\n\n    unit = input.getAttribute(\"data-style_unit\");\n\n    switch (dataAttribute) {\n      case \"classstyle\":\n        // when input is empty remove that style\n        if (!input.value) {\n          removeccCssStyle(element.classList, dataProperty);\n          isColl && collaborate({\n            value: value,\n            input: input,\n            dataProperty: dataProperty,\n            dataAttribute: dataAttribute,\n            element: element,\n            elementId: elementId\n          });\n          return;\n        } // when there is style set that\n\n\n        style = value + unit;\n        element.setCCStyle(dataProperty, style);\n        isColl && collaborate({\n          value: value,\n          unit: unit,\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        });\n        break;\n\n      case \"style\":\n        // let computedStyles = getRealStaticCompStyle(element);\n        // let styleValue = computedStyles[dataProperty];\n        if (!input.value) {\n          element.setStlyeIfDiffer(camelDataProperty, \"\") && isColl && collaborate({\n            value: value,\n            input: input,\n            dataProperty: dataProperty,\n            dataAttribute: dataAttribute,\n            element: element,\n            elementId: elementId\n          }); // element.style[dataProperty] = \"\";\n\n          return;\n        }\n\n        style = value + unit;\n        element.setStlyeIfDiffer(camelDataProperty, style) && isColl && collaborate({\n          value: value,\n          unit: unit,\n          input: input,\n          dataProperty: dataProperty,\n          dataAttribute: dataAttribute,\n          element: element,\n          elementId: elementId\n        }); // element.style[dataProperty] = style;\n\n        break;\n\n      default:\n    }\n  }\n}\n\nfunction toCamelCase(str) {\n  var index = 0;\n\n  do {\n    index = str.indexOf(\"-\", index);\n\n    if (index !== -1) {\n      var t = str.substring(0, index);\n      t += String.fromCharCode(str.charCodeAt(index + 1) - 32);\n      t += str.substr(index + 2);\n      str = t;\n    } else break;\n  } while (true);\n\n  return str;\n}\n\nfunction setAttributeIfDiffer(property, value) {\n  if (this.getAttribute(property) !== value) this.setAttribute(property, value);\n}\n\nfunction setStlyeIfDiffer(property, value) {\n  var computedStyles = getRealStaticCompStyle(this);\n\n  if (computedStyles[property] !== value) {\n    this.style[property] = value;\n    return true;\n  } else return false;\n}\n\nfunction addClassIfDiffer(className) {\n  if (!this.classList.has(className)) this.classList.add(className);\n}\n\nfunction setCCStyle(property, newValue) {\n  var _iterator2 = _createForOfIteratorHelper(this.classList),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var classname = _step2.value;\n\n      var _classname$split5 = classname.split(\":\"),\n          _classname$split6 = _slicedToArray(_classname$split5, 2),\n          name = _classname$split6[0],\n          value = _classname$split6[1];\n\n      if (name === property) {\n        this.classList.replace(classname, property + \":\" + newValue);\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  this.classList.add(property + \":\" + newValue);\n}\n\nfunction getCCStyle(property) {\n  var styleMap = new Map();\n\n  var _iterator3 = _createForOfIteratorHelper(this.classList),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var classname = _step3.value;\n\n      var _classname$split7 = classname.split(\":\"),\n          _classname$split8 = _slicedToArray(_classname$split7, 2),\n          name = _classname$split8[0],\n          value = _classname$split8[1];\n\n      if (name === property) {\n        return value;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nvar tools = {};\n\nfunction init(_ref) {\n  var windowObject = _ref.windowObject,\n      docObject = _ref.docObject,\n      isIframe = _ref.isIframe,\n      frame = _ref.frame,\n      onCollaboration = _ref.onCollaboration;\n  var ref;\n  tools.onCollaboration = onCollaboration;\n\n  if (isIframe) {\n    var frameWindow = frame.contentWindow;\n    var frameDocument = frameWindow.document || frame.contentDocument;\n    ref = {\n      frame: frame,\n      window: frameWindow,\n      document: frameDocument,\n      isIframe: true\n    };\n    allFrames.set(frame, ref);\n  } else {\n    ref = {\n      window: windowObject,\n      document: docObject,\n      isIframe: false\n    };\n    allFrames.set(\"main\", ref);\n  }\n\n  ref.window.HTMLElement.prototype.setAttributeIfDiffer = setAttributeIfDiffer;\n  ref.window.HTMLElement.prototype.setStlyeIfDiffer = setStlyeIfDiffer;\n  ref.window.HTMLElement.prototype.addClassIfDiffer = addClassIfDiffer;\n  ref.window.HTMLElement.prototype.setCCStyle = setCCStyle;\n  ref.window.HTMLElement.prototype.getCCStyle = getCCStyle;\n  ref.window.addEventListener(\"load\", function () {\n    ref.window.CoCreateObserver.add({\n      name: \"ccStyle\",\n      observe: [\"attributes\"],\n      attributes: [\"data-style_target\", \"value\"],\n      include: \"INPUT, .pickr\",\n      task: watchInputChange\n    });\n  });\n  ref.document.addEventListener(\"input\", function (e) {\n    var input = e.target; // input.isReactive = true;\n\n    var inputMeta = validateNewInput(input);\n    if (!inputMeta) return;\n    var elementId = input.getAttribute(\"data-style_target\");\n    updateElement(inputMeta, elementId, true);\n  });\n}\n\nfunction addFilter(selector) {\n  filters.push(selector);\n}\n\nwindow.ccStyle = {\n  init: init,\n  addFilter: addFilter\n};\nwindow.addEventListener(\"load\", function () {\n  window.CoCreateObserver.add({\n    name: \"ccStyle\",\n    observe: [\"attributes\"],\n    attributes: [\"data-style_target\", \"value\"],\n    include: \"INPUT, .pickr\",\n    task: watchInputChange\n  });\n  init({\n    windowObject: window,\n    docObject: document\n  });\n});\nCoCreateSocket.listen(\"ccStyle\", function (_ref2) {\n  var value = _ref2.value,\n      dataAttribute = _ref2.dataAttribute,\n      dataProperty = _ref2.dataProperty,\n      elementId = _ref2.elementId,\n      unit = _ref2.unit;\n  var inputs = allFrame(function (frame) {\n    return frame.querySelector(\"[data-style=\".concat(dataAttribute, \"][data-style_sync=\").concat(dataProperty, \"]\"));\n  });\n  inputs.forEach(function (input) {\n    updateElementValue(value + unit, dataAttribute, dataProperty, elementId);\n  });\n});\n\nfunction collaborate(_ref3) {\n  var value = _ref3.value,\n      input = _ref3.input,\n      dataProperty = _ref3.dataProperty,\n      dataAttribute = _ref3.dataAttribute,\n      elementId = _ref3.elementId,\n      element = _ref3.element,\n      unit = _ref3.unit;\n  // if (value != input.value) return;\n  tools.onCollaboration({\n    value: value,\n    unit: unit,\n    dataProperty: dataProperty,\n    dataAttribute: dataAttribute,\n    element: element\n  });\n  CoCreate.sendMessage({\n    broadcast_sender: false,\n    rooms: \"\",\n    emit: {\n      message: \"ccStyle\",\n      data: {\n        value: value,\n        unit: unit,\n        dataProperty: dataProperty,\n        dataAttribute: dataAttribute,\n        elementId: elementId\n      }\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZVNlbGVjdGVkLy4vc3JjL0NvQ3JlYXRlLXN0eWxlcy5qcz80MzdlIl0sIm5hbWVzIjpbInBpY2tyUmVmcyIsIndpbmRvdyIsIkNvQ3JlYXRlUGlja3IiLCJyZWZzIiwiZmlsdGVycyIsImFsbEZyYW1lcyIsIk1hcCIsImFsbEZyYW1lIiwiY2FsbGJhY2siLCJyZXN1bHQiLCJTZXQiLCJmcmFtZU9iamVjdCIsImZyYW1lIiwiY2FsbGJhY2tSZXN1bHQiLCJkb2N1bWVudCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZm9yRWFjaCIsImVsIiwiYWRkIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwic29tZSIsIm1hdGNoZXMiLCJ3YXRjaElucHV0Q2hhbmdlIiwibXV0YXRpb24iLCJpbnB1dE1ldGEiLCJ2YWxpZGF0ZU5ld0lucHV0IiwidGFyZ2V0IiwiYXR0cmlidXRlTmFtZSIsImVsZW1lbnQiLCJnZXRFbGVtZW50IiwiaW5wdXQiLCJ1cGRhdGVJbnB1dCIsImdldElucHV0cyIsImlucHV0cyIsImFsbElucHV0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5wdXRDYW5kaWRhdGUiLCJhbGxSZWZlcmVuY2VkRWwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0QXR0cmlidXRlIiwiaW5jbHVkZXMiLCJwdXNoIiwiaWQiLCJxdWVyeVNlbGVjdG9yIiwiY2FjaGUiLCJnZXRSZWFsU3RhdGljQ29tcFN0eWxlIiwic2hvdWxkQ2FjaGUiLCJoYXMiLCJnZXQiLCJsZW5ndGgiLCJvbGREaXNwYWx5Iiwic3R5bGUiLCJkaXNwbGF5IiwiY29tcHV0ZWRTdHlsZXNMaXZlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNvbXB1dGVkU3R5bGVzIiwiT2JqZWN0IiwiYXNzaWduIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0IiwiZGF0YUF0dHJpYnV0ZSIsInRvTG93ZXJDYXNlIiwiZGF0YVByb3BlcnR5IiwicGFyc2VVbml0IiwidmFsdWUiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJ2YWx1ZUxlbmd0aCIsInN1YnN0ciIsImdldENvQ3JlYXRlU3R5bGUiLCJjbGFzc0xpc3QiLCJzdHlsZXMiLCJjbGFzc25hbWUiLCJzcGxpdCIsIm5hbWUiLCJwdXRDb0NyZWF0ZVN0eWxlIiwibmV3U3R5bGVzIiwic3R5bGVNYXAiLCJlbnRyaWVzIiwicmVtb3ZlIiwicmVtb3ZlY2NDc3NTdHlsZSIsInByb3BlcnR5IiwiY29DcmVhdGVDc3MiLCJhc3NpZ25FbGVtZW50SWQiLCJpc1JlYWN0aXZlIiwiZWxlbWVudElkIiwic2V0QXR0cmlidXRlSWZEaWZmZXIiLCJyZ2JhMmhleCIsIm9yaWciLCJhIiwiaXNQZXJjZW50IiwicmdiIiwicmVwbGFjZSIsIm1hdGNoIiwiYWxwaGEiLCJ0cmltIiwiaGV4IiwidG9TdHJpbmciLCJzbGljZSIsInNldFBsYWNlSG9sZGVycyIsImNtbERhdGFQcm9wZXJ0eSIsInRvQ2FtZWxDYXNlIiwiaW5wdXRFbGVtZW50SWQiLCJ1bml0IiwidHlwZSIsImNvbnRhaW5zIiwicGlja3JJbnMiLCJkaXNhYmxlZEV2ZW50Iiwic2V0Q29sb3IiLCJ1cGRhdGVFbGVtZW50VmFsdWUiLCJjYW1lbERhdGFQcm9wZXJ0eSIsInNldENDU3R5bGUiLCJzZXRTdGx5ZUlmRGlmZmVyIiwidXBkYXRlRWxlbWVudCIsImlzQ29sbCIsImdldENvbG9yIiwidG9IRVhBIiwiY29sbGFib3JhdGUiLCJzdHIiLCJpbmRleCIsImluZGV4T2YiLCJ0Iiwic3Vic3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY2hhckNvZGVBdCIsInNldEF0dHJpYnV0ZSIsImFkZENsYXNzSWZEaWZmZXIiLCJjbGFzc05hbWUiLCJuZXdWYWx1ZSIsImdldENDU3R5bGUiLCJ0b29scyIsImluaXQiLCJ3aW5kb3dPYmplY3QiLCJkb2NPYmplY3QiLCJpc0lmcmFtZSIsIm9uQ29sbGFib3JhdGlvbiIsInJlZiIsImZyYW1lV2luZG93IiwiY29udGVudFdpbmRvdyIsImZyYW1lRG9jdW1lbnQiLCJjb250ZW50RG9jdW1lbnQiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJDb0NyZWF0ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJpbmNsdWRlIiwidGFzayIsImUiLCJhZGRGaWx0ZXIiLCJzZWxlY3RvciIsImNjU3R5bGUiLCJDb0NyZWF0ZVNvY2tldCIsImxpc3RlbiIsIkNvQ3JlYXRlIiwic2VuZE1lc3NhZ2UiLCJicm9hZGNhc3Rfc2VuZGVyIiwicm9vbXMiLCJlbWl0IiwibWVzc2FnZSIsImRhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQSxJQUFJQSxTQUFTLEdBQUdDLE1BQU0sQ0FBQ0MsYUFBUCxDQUFxQkMsSUFBckM7QUFFQSxJQUFJQyxPQUFPLEdBQUcsRUFBZDtBQUNBLElBQUlDLFNBQVMsR0FBRyxJQUFJQyxHQUFKLEVBQWhCOztBQUVBLFNBQVNDLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCO0FBQzFCLE1BQUlDLE1BQU0sR0FBRyxJQUFJQyxHQUFKLEVBQWI7O0FBRDBCLDZDQUVPTCxTQUZQO0FBQUE7O0FBQUE7QUFFMUIsd0RBQTRDO0FBQUE7QUFBQSxVQUFsQ00sV0FBa0M7QUFBQSxVQUFyQkMsS0FBcUI7O0FBQzFDLFVBQUlDLGNBQWMsR0FBR0wsUUFBUSxDQUFDSSxLQUFLLENBQUNFLFFBQVAsRUFBaUJGLEtBQUssQ0FBQ1gsTUFBdkIsQ0FBN0I7QUFDQSxVQUNFWSxjQUFjLElBQ2QsT0FBT0EsY0FBYyxDQUFDRSxNQUFNLENBQUNDLFFBQVIsQ0FBckIsS0FBMkMsVUFGN0MsRUFJRUgsY0FBYyxDQUFDSSxPQUFmLENBQXVCLFVBQUNDLEVBQUQ7QUFBQSxlQUFRVCxNQUFNLENBQUNVLEdBQVAsQ0FBV0QsRUFBWCxDQUFSO0FBQUEsT0FBdkIsRUFKRixLQUtLLElBQUlMLGNBQUosRUFBb0JKLE1BQU0s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dGlvbk9ic2VydmVyKi9cbi8qKlxuICogZGF0YS1zdHlsZTogY2xhc3NTdHlsZSB8IHN0eWxlIHwgYXR0cmlidXRlXG4gKiBkYXRhLXN0eWxlX3N5bmM6IGFueSB2YWxpZCBjc3MgcHJvcGVydHlcbiAqIGRhdGEtc3R5bGVfdW5pdDogYW55IHZhbGlkIGNzcyB1bml0IHR5cGVcbiAqIGRhdGEtc3R5bGVfdGFyZ2V0OiB1bmlxdWUgaWQgb2YgZWxlbWVudCB3cml0dGVuIHRvIGRhdGEtZWxlbWVudF9pZFxuICovXG5cbi8vIHRvZG86IGRpc2FibGUgaW5wdXQgd2hlbiB0aGVyZSBpcyBubyBkYXRhLXN0eWxlLCB0aGVyZSBpcyBubyByZWFzb24gaXQgdG8gaGF2ZSBkZWZhdWx0IHZhbHVlIGl0IHNob3VsZCBiZVxuLy8gZGlzYWJsZWRcbi8vIGltcG9ydCB7IHJlZnMgYXMgcGlja3JSZWZzIH0gZnJvbSAnLi4vLi4vQ29DcmVhdGUtYnVpbGRlci9zcmMvcGlja3IuanMnO1xuXG4vL2R1bW15IGNoYW5nZSAyXG5sZXQgcGlja3JSZWZzID0gd2luZG93LkNvQ3JlYXRlUGlja3IucmVmcztcblxubGV0IGZpbHRlcnMgPSBbXTtcbmxldCBhbGxGcmFtZXMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGFsbEZyYW1lKGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gIGZvciAobGV0IFtmcmFtZU9iamVjdCwgZnJhbWVdIG9mIGFsbEZyYW1lcykge1xuICAgIGxldCBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrKGZyYW1lLmRvY3VtZW50LCBmcmFtZS53aW5kb3cpO1xuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrUmVzdWx0ICYmXG4gICAgICB0eXBlb2YgY2FsbGJhY2tSZXN1bHRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKVxuICAgICAgY2FsbGJhY2tSZXN1bHQuZm9yRWFjaCgoZWwpID0+IHJlc3VsdC5hZGQoZWwpKTtcbiAgICBlbHNlIGlmIChjYWxsYmFja1Jlc3VsdCkgcmVzdWx0LmFkZChjYWxsYmFja1Jlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpLmZpbHRlcihcbiAgICAoZWwpID0+ICFmaWx0ZXJzLnNvbWUoKGZpbHRlcikgPT4gZWwubWF0Y2hlcyhmaWx0ZXIpKVxuICApO1xufVxuXG5cbmZ1bmN0aW9uIHdhdGNoSW5wdXRDaGFuZ2UobXV0YXRpb24pIHtcbiAgbGV0IGlucHV0TWV0YSA9IHZhbGlkYXRlTmV3SW5wdXQobXV0YXRpb24udGFyZ2V0KTtcbiAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcblxuICBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJkYXRhLXN0eWxlX3RhcmdldFwiKSB7XG4gICAgbGV0IGVsZW1lbnQgPSBnZXRFbGVtZW50KGlucHV0TWV0YS5pbnB1dCk7XG4gICAgaWYgKGVsZW1lbnQpIHVwZGF0ZUlucHV0KGVsZW1lbnQsIFtpbnB1dE1ldGEuaW5wdXRdKTtcbiAgfVxuICAvLyBlbHNlIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgLy8gICBsZXQgeyBpbnB1dCwgZGF0YUF0dHJpYnV0ZSwgZGF0YVByb3BlcnR5IH0gPSBpbnB1dE1ldGE7XG4gIC8vICAgbGV0IGVsZW1lbnRJZCA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVfdGFyZ2V0XCIpO1xuICAvLyAgIHVwZGF0ZUVsZW1lbnQoaW5wdXRNZXRhLCBlbGVtZW50SWQsIHRydWUpO1xuICAvLyB9XG59XG5cbi8vIGZ1bmN0aW9uIHdhdGNoRWxlbWVudENoYW5nZShtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikge1xuLy8gICBmb3IgKGxldCBtdXRhdGlvbiBvZiBtdXRhdGlvbnNMaXN0KSB7XG4vLyAgICAgdXBkYXRlSW5wdXQobXV0YXRpb24udGFyZ2V0KTtcbi8vICAgfVxuLy8gfVxuXG4vLyBmdW5jdGlvbiB3YXRjaElucHV0Q2hhbmdlKG11dGF0aW9uc0xpc3QsIG9ic2VydmVyKSB7XG4vLyAgIHdhdGNoRWxlbWVudENoYW5nZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbi8vICAgZm9yIChsZXQgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdClcbi8vICAgICBpZiAoXG4vLyAgICAgICAvLyBtdXRhdGlvbi50YXJnZXQuaXNSZWFjdGl2ZSAhPT0gZmFsc2UgJiZcbi8vICAgICAgIG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmXG4vLyAgICAgICBtdXRhdGlvbi50YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiXG4vLyAgICAgKSB7XG4vLyAgICAgICBsZXQgaW5wdXRNZXRhID0gdmFsaWRhdGVOZXdJbnB1dChtdXRhdGlvbi50YXJnZXQpO1xuLy8gICAgICAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcblxuLy8gICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwiZGF0YS1zdHlsZV90YXJnZXRcIikge1xuLy8gICAgICAgICBsZXQgZWxlbWVudCA9IGdldEVsZW1lbnQoaW5wdXRNZXRhLmlucHV0KTtcbi8vICAgICAgICAgLy8gbXV0YXRpb24udGFyZ2V0LmlzUmVhY3RpdmUgPSBmYWxzZTtcblxuLy8gICAgICAgICB1cGRhdGVJbnB1dChlbGVtZW50LCBbaW5wdXRNZXRhLmlucHV0XSk7XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICB1cGRhdGVFbGVtZW50KGlucHV0TWV0YSk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB3YXRjaEVsZW1lbnRDaGFuZ2VPYnNlcnZlci5vYnNlcnZlKGNhbnZhcywgY29uZmlnRWxlbWVudCk7Ly8gdG9kbzogbm8gY2FudmFzXG4vLyB9XG5cbi8vIGNhbnZhcy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuLy8gICB1cGRhdGVJbnB1dChlLnRhcmdldClcbi8vIH0pO1xuXG5mdW5jdGlvbiBnZXRJbnB1dHMoZWxlbWVudCkge1xuICBsZXQgaW5wdXRzID0gW107XG4gIGxldCBhbGxJbnB1dHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIikpO1xuICBhbGxJbnB1dHMuZm9yRWFjaCgoaW5wdXRDYW5kaWRhdGUpID0+IHtcbiAgICBsZXQgaW5wdXRNZXRhID0gdmFsaWRhdGVOZXdJbnB1dChpbnB1dENhbmRpZGF0ZSk7XG4gICAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcblxuICAgIGxldCBhbGxSZWZlcmVuY2VkRWwgPSBhbGxGcmFtZSgoZnJhbWUpID0+XG4gICAgICBmcmFtZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBpbnB1dE1ldGEuaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZV90YXJnZXRcIilcbiAgICAgIClcbiAgICApO1xuICAgIGlmIChBcnJheS5mcm9tKGFsbFJlZmVyZW5jZWRFbCkuaW5jbHVkZXMoZWxlbWVudCkpIHtcbiAgICAgIGlucHV0cy5wdXNoKGlucHV0TWV0YS5pbnB1dCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGlucHV0cztcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudChpbnB1dCkge1xuICBsZXQgaWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlX3RhcmdldFwiKTtcbiAgaWYgKGlkKSByZXR1cm4gYWxsRnJhbWUoKGZyYW1lKSA9PiBmcmFtZS5xdWVyeVNlbGVjdG9yKGlkKSlbMF07XG4gIGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuLy8gZnVuY3Rpb24gZ2V0UmVhbFN0YXRpY0NvbXBTdHlsZU9sZChlbGVtZW50KSB7XG4vLyAgIC8vIGNhbGN1bGF0ZSByZWFsIGNzcyBpbnN0ZWFkIG9mIGNvbXVwdGVkIGVsZW1lbnRcbi8vICAgd2F0Y2hFbGVtZW50Q2hhbmdlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuLy8gICBsZXQgb2xkRGlzcGFseSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcblxuLy8gICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuLy8gICBsZXQgY29tcHV0ZWRTdHlsZXNMaXZlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4vLyAgIGxldCBjb21wdXRlZFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbXB1dGVkU3R5bGVzTGl2ZSk7XG4vLyAgIGNvbXB1dGVkU3R5bGVzLmRpc3BsYXkgPSBvbGREaXNwYWx5O1xuXG4vLyAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG9sZERpc3BhbHk7XG4vLyAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpID09IFwiXCIpIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4vLyAgIHdhdGNoRWxlbWVudENoYW5nZU9ic2VydmVyLm9ic2VydmUoY2FudmFzLCBjb25maWdFbGVtZW50KTtcbi8vICAgcmV0dXJuIGNvbXB1dGVkU3R5bGVzO1xuLy8gfVxuLy8gZnVuY3Rpb24gZ2V0QWxsU3R5bGVzKCkge1xuLy8gICBmb3IgKGxldCBzdHlsZVNoZWV0IG9mIGRvY3VtZW50LnN0eWxlU2hlZXRzKSB7XG4vLyAgICAgbGV0IHN0eWxlO1xuLy8gICAgIHRyeSB7XG4vLyAgICAgICBzdHlsZSA9IHN0eWxlU2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVTaGVldC5ydWxlcztcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xuLy8gICAgICAgY29uc29sZS5sb2coXCJjb3VsZG4ndCBwYXJzZSBzdHlsZVwiKTtcbi8vICAgICB9XG4vLyAgICAgaWYoIXN0eWxlKSBjb250aW51ZTtcbi8vICAgICAgIGZvciAobGV0IHJ1bGUgb2Ygc3R5bGUpIHtcbi8vICAgICAgICAgbGV0IHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvclRleHQ7XG4vLyAgICAgICAgIHF1ZXJ5U2VsZWN0b3JBbGxcbi8vICAgICAgIH1cbi8vICAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbi8vICAgfVxuLy8gfVxuLy8gZ2V0QWxsU3R5bGVzKCk7XG5sZXQgY2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRSZWFsU3RhdGljQ29tcFN0eWxlKGVsZW1lbnQpIHtcbiAgbGV0IHNob3VsZENhY2hlID0gZmFsc2U7XG4gIGlmKGNhY2hlLmhhcyhlbGVtZW50KSlcbiAge1xuICAgIHJldHVybiBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIH1lbHNlIGlmKGNhY2hlLmxlbmd0aCA8IDEwKVxuICB7XG4gICAgc2hvdWxkQ2FjaGUgPSB0cnVlO1xuICB9XG4gIC8vIGNhbGN1bGF0ZSByZWFsIGNzcyBpbnN0ZWFkIG9mIGNvbXVwdGVkIGVsZW1lbnRcbiAgLy8gd2F0Y2hFbGVtZW50Q2hhbmdlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICBsZXQgb2xkRGlzcGFseSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgLy8gZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vLW9ic2VydmUnLCB0cnVlKVxuICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICBsZXQgY29tcHV0ZWRTdHlsZXNMaXZlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGxldCBjb21wdXRlZFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbXB1dGVkU3R5bGVzTGl2ZSk7XG4gIGNvbXB1dGVkU3R5bGVzLmRpc3BsYXkgPSBvbGREaXNwYWx5O1xuXG4gIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG9sZERpc3BhbHk7XG4gIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpID09IFwiXCIpIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gIC8vIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCduby1vYnNlcnZlJylcbiAgLy8gd2F0Y2hFbGVtZW50Q2hhbmdlT2JzZXJ2ZXIub2JzZXJ2ZShjYW52YXMsIGNvbmZpZ0VsZW1lbnQpO1xuICBpZihzaG91bGRDYWNoZSlcbiAgICBjYWNoZS5zZXQoZWxlbWVudCwgY29tcHV0ZWRTdHlsZXMpO1xuICByZXR1cm4gY29tcHV0ZWRTdHlsZXM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTmV3SW5wdXQoaW5wdXQpIHtcbiAgbGV0IGRhdGFBdHRyaWJ1dGUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlXCIpO1xuICBpZiAoIWRhdGFBdHRyaWJ1dGUpIHJldHVybjtcbiAgLy8gY29uc29sZS53YXJuKFwiY2Mtc3R5bGU6IGlucHV0IGRvZXNuJ3QgaGF2ZSBkYXRhLXN0eWxlXCIpXG4gIGRhdGFBdHRyaWJ1dGUgPSBkYXRhQXR0cmlidXRlLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBkYXRhUHJvcGVydHkgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlX3N5bmNcIik7XG4gIGlmICghZGF0YVByb3BlcnR5KSByZXR1cm47XG4gIC8vIGNvbnNvbGUud2FybihcImNjLXN0eWxlOiBpbnB1dCBkb2Vzbid0IGhhdmUgZGF0YS1zdHlsZVwiKVxuICBkYXRhUHJvcGVydHkgPSBkYXRhUHJvcGVydHkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dCxcbiAgICBkYXRhQXR0cmlidXRlLFxuICAgIGRhdGFQcm9wZXJ0eSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml0KHN0eWxlKSB7XG4gIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGUpO1xuICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgIGxldCB2YWx1ZUxlbmd0aCA9ICh2YWx1ZSArIFwiXCIpLmxlbmd0aDtcbiAgICByZXR1cm4gW3ZhbHVlLCBzdHlsZS5zdWJzdHIodmFsdWVMZW5ndGgpIHx8IFwibm9uZVwiXTtcbiAgfVxuICByZXR1cm4gW3N0eWxlLCBcIlwiXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29DcmVhdGVTdHlsZShjbGFzc0xpc3QpIHtcbiAgbGV0IHN0eWxlcyA9IHt9O1xuICBjbGFzc0xpc3QuZm9yRWFjaCgoY2xhc3NuYW1lKSA9PiB7XG4gICAgbGV0IFtuYW1lLCB2YWx1ZV0gPSBjbGFzc25hbWUuc3BsaXQoXCI6XCIpO1xuICAgIHN0eWxlc1tuYW1lXSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBwdXRDb0NyZWF0ZVN0eWxlKGNsYXNzTGlzdCwgbmV3U3R5bGVzKSB7XG4gIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgY2xhc3NMaXN0LmZvckVhY2goKGNsYXNzbmFtZSkgPT4ge1xuICAgIGxldCBbbmFtZSwgdmFsdWVdID0gY2xhc3NuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBzdHlsZU1hcC5zZXQobmFtZSwgdmFsdWUpO1xuICB9KTtcblxuICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5ld1N0eWxlcykpIHtcbiAgICBpZiAoc3R5bGVNYXAuaGFzKG5hbWUpKSB7XG4gICAgICBsZXQgdmFsdWUgPSBzdHlsZU1hcC5nZXQobmFtZSk7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKG5hbWUgKyBcIjpcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgY2xhc3NMaXN0LmFkZChuYW1lICsgXCI6XCIgKyB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlY2NDc3NTdHlsZShjbGFzc0xpc3QsIHByb3BlcnR5KSB7XG4gIGxldCBjb0NyZWF0ZUNzcyA9IGdldENvQ3JlYXRlU3R5bGUoY2xhc3NMaXN0KTtcbiAgZGVsZXRlIGNvQ3JlYXRlQ3NzW3Byb3BlcnR5XTtcbiAgcHV0Q29DcmVhdGVTdHlsZShjbGFzc0xpc3QsIGNvQ3JlYXRlQ3NzKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduRWxlbWVudElkKGVsZW1lbnQsIGlzUmVhY3RpdmUgPSBmYWxzZSkge1xuICBsZXQgaW5wdXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpKTtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0Q2FuZGlkYXRlKSA9PiB7XG4gICAgbGV0IGlucHV0TWV0YSA9IHZhbGlkYXRlTmV3SW5wdXQoaW5wdXRDYW5kaWRhdGUpO1xuICAgIGlmICghaW5wdXRNZXRhKSByZXR1cm47XG4gICAgbGV0IHsgaW5wdXQsIGRhdGFBdHRyaWJ1dGUsIGRhdGFQcm9wZXJ0eSB9ID0gaW5wdXRNZXRhO1xuXG4gICAgaW5wdXQuaXNSZWFjdGl2ZSA9IGlzUmVhY3RpdmU7XG4gICAgbGV0IGVsZW1lbnRJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50X2lkXCIpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZUlmRGlmZmVyKFxuICAgICAgXCJkYXRhLXN0eWxlX3RhcmdldFwiLFxuICAgICAgYFtkYXRhLWVsZW1lbnRfaWQ9JHtlbGVtZW50SWR9XWBcbiAgICApO1xuICB9KTtcbn1cblxuLy8gcGlja2VkIHVwIGZyb20gc3RhY2tvdmVyZmxvd1xuZnVuY3Rpb24gcmdiYTJoZXgob3JpZykge1xuICBsZXQgYSwgaXNQZXJjZW50LFxuICAgIHJnYiA9IG9yaWcucmVwbGFjZSgvXFxzL2csICcnKS5tYXRjaCgvXnJnYmE/XFwoKFxcZCspLChcXGQrKSwoXFxkKyksPyhbXixcXHMpXSspPy9pKSxcbiAgICBhbHBoYSA9IChyZ2IgJiYgcmdiWzRdIHx8IFwiXCIpLnRyaW0oKSxcbiAgICBoZXggPSByZ2IgP1xuICAgIChyZ2JbMV0gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSArXG4gICAgKHJnYlsyXSB8IDEgPDwgOCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpICtcbiAgICAocmdiWzNdIHwgMSA8PCA4KS50b1N0cmluZygxNikuc2xpY2UoMSkgOiBvcmlnO1xuXG4gIGlmIChhbHBoYSAhPT0gXCJcIikge1xuICAgIGEgPSBhbHBoYTtcbiAgfVxuICBlbHNlIHtcbiAgICBhID0gMTtcbiAgfVxuICAvLyBtdWx0aXBseSBiZWZvcmUgY29udmVydCB0byBIRVhcbiAgYSA9ICgoYSAqIDI1NSkgfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKVxuICBoZXggPSBoZXggKyBhO1xuXG4gIHJldHVybiBoZXg7XG59XG5cbi8vIG11dGF0aW9uIHJlZmxlY3QgZGF0YS1zdHlsZV91bml0XG5mdW5jdGlvbiBzZXRQbGFjZUhvbGRlcnMoZWxlbWVudCkge1xuICBsZXQgaW5wdXRzID0gZ2V0SW5wdXRzKGVsZW1lbnQpO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXRDYW5kaWRhdGUpID0+IHtcbiAgICBsZXQgaW5wdXRNZXRhID0gdmFsaWRhdGVOZXdJbnB1dChpbnB1dENhbmRpZGF0ZSk7XG4gICAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcbiAgICBsZXQgeyBpbnB1dCwgZGF0YUF0dHJpYnV0ZSwgZGF0YVByb3BlcnR5IH0gPSBpbnB1dE1ldGE7XG4gICAgbGV0IGNtbERhdGFQcm9wZXJ0eSA9IHRvQ2FtZWxDYXNlKGRhdGFQcm9wZXJ0eSk7XG4gICAgbGV0IGVsZW1lbnRJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50X2lkXCIpO1xuICAgIGlmICghZWxlbWVudElkKSByZXR1cm47XG4gICAgbGV0IGlucHV0RWxlbWVudElkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZV90YXJnZXRcIik7XG4gICAgaWYgKGVsZW1lbnRJZCAhPSBpbnB1dEVsZW1lbnRJZCkge1xuICAgICAgbGV0IGNvbXB1dGVkU3R5bGVzID0gZ2V0UmVhbFN0YXRpY0NvbXBTdHlsZShlbGVtZW50KTtcbiAgICAgIGxldCBzdHlsZTtcbiAgICAgIHN3aXRjaCAoZGF0YUF0dHJpYnV0ZSkge1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBzdHlsZSA9IGNvbXB1dGVkU3R5bGVzW2NtbERhdGFQcm9wZXJ0eV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjbGFzc3N0eWxlXCI6XG4gICAgICAgICAgbGV0IGNvQ3JlYXRlQ3NzID0gZ2V0Q29DcmVhdGVTdHlsZShlbGVtZW50LmNsYXNzTGlzdCk7XG4gICAgICAgICAgc3R5bGUgPSBjb0NyZWF0ZUNzc1tjbWxEYXRhUHJvcGVydHldO1xuICAgICAgICAgIGlmICghc3R5bGUpIHN0eWxlID0gY29tcHV0ZWRTdHlsZXNbY21sRGF0YVByb3BlcnR5XTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0eWxlID0gY29tcHV0ZWRTdHlsZXNbY21sRGF0YVByb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIC8vIHN0eWxlPSB0cnVlO1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIHVuaXRcbiAgICAgIC8vIHRvZG86IHdoeSBpdCdzIGxvb2sgbGlrZSB1cGRhdGUgaW5wdXQ/IHNob3VsZCBpIHVwZGF0ZT9cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgW3ZhbHVlLCB1bml0XSA9IHBhcnNlVW5pdChzdHlsZSk7XG5cbiAgICAgICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAvLyBDb0NyZWF0ZS5yZXBsYWNlRGF0YUNyZHQoe1xuICAgICAgICAgICAgLy8gICBjb2xsZWN0aW9uOiAnYnVpbGRlcicsXG4gICAgICAgICAgICAvLyAgIGRvY3VtZW50X2lkOiAnbnVsbCcsXG4gICAgICAgICAgICAvLyAgIG5hbWU6IGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgICAgLy8gICB2YWx1ZTogdmFsdWUgKyAnJyxcbiAgICAgICAgICAgIC8vICAgcG9zaXRpb246ICcwJyxcbiAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHJnYmEyaGV4KHZhbHVlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIENvQ3JlYXRlLnJlcGxhY2VEYXRhQ3JkdCh7XG4gICAgICAgICAgICAvLyAgIGNvbGxlY3Rpb246ICdidWlsZGVyJyxcbiAgICAgICAgICAgIC8vICAgZG9jdW1lbnRfaWQ6ICdudWxsJyxcbiAgICAgICAgICAgIC8vICAgbmFtZTogaW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJyksXG4gICAgICAgICAgICAvLyAgIHZhbHVlOiB2YWx1ZSArICcnLFxuICAgICAgICAgICAgLy8gICBwb3NpdGlvbjogJzAnLFxuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWUgKyAnJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlSWZEaWZmZXIoXCJkYXRhLXN0eWxlX3VuaXRcIiwgdW5pdCB8fCAnJyk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xufVxuXG5cblxuZnVuY3Rpb24gdXBkYXRlSW5wdXQoZWxlbWVudCwgaW5wdXRzKSB7XG4gIGxldCBjb21wdXRlZFN0eWxlcyA9IGdldFJlYWxTdGF0aWNDb21wU3R5bGUoZWxlbWVudCk7XG4gIC8vIGxldCBjb21wdXRlZFN0eWxlcyA9IHt9O1xuICBpZiAoIWlucHV0cykgaW5wdXRzID0gZ2V0SW5wdXRzKGVsZW1lbnQpO1xuXG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dENhbmRpZGF0ZSkgPT4ge1xuICAgIGxldCBpbnB1dE1ldGEgPSB2YWxpZGF0ZU5ld0lucHV0KGlucHV0Q2FuZGlkYXRlKTtcbiAgICBpZiAoIWlucHV0TWV0YSkgcmV0dXJuO1xuICAgIGxldCB7IGlucHV0LCBkYXRhQXR0cmlidXRlLCBkYXRhUHJvcGVydHkgfSA9IGlucHV0TWV0YTtcbiAgICBsZXQgY21sRGF0YVByb3BlcnR5ID0gdG9DYW1lbENhc2UoZGF0YVByb3BlcnR5KTtcbiAgICBsZXQgZWxlbWVudElkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnRfaWRcIik7XG4gICAgaWYgKCFlbGVtZW50SWQpIHJldHVybjtcblxuICAgIC8vY2FsY3VsYXRlIHN0eWxlXG4gICAgbGV0IHN0eWxlO1xuICAgIHN3aXRjaCAoZGF0YUF0dHJpYnV0ZSkge1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIHN0eWxlID0gY29tcHV0ZWRTdHlsZXNbY21sRGF0YVByb3BlcnR5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xhc3NzdHlsZVwiOlxuICAgICAgICBsZXQgY29DcmVhdGVDc3MgPSBnZXRDb0NyZWF0ZVN0eWxlKGVsZW1lbnQuY2xhc3NMaXN0KTtcbiAgICAgICAgc3R5bGUgPSBjb0NyZWF0ZUNzc1tjbWxEYXRhUHJvcGVydHldO1xuICAgICAgICBpZiAoIXN0eWxlKSBzdHlsZSA9IGNvbXB1dGVkU3R5bGVzW2NtbERhdGFQcm9wZXJ0eV07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdHlsZSA9IGNvbXB1dGVkU3R5bGVzW2NtbERhdGFQcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHN0eWxlIHVuaXRcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGxldCBbdmFsdWUsIHVuaXRdID0gcGFyc2VVbml0KHN0eWxlKTtcblxuICAgICAgaWYgKGlucHV0TWV0YS5pbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJ3BpY2tyJykpIHtcbiAgICAgICAgaWYgKCFwaWNrclJlZnMuaGFzKGlucHV0KSkgcmV0dXJuO1xuICAgICAgICBsZXQgcGlja3JJbnMgPSBwaWNrclJlZnMuZ2V0KGlucHV0KTtcbiAgICAgICAgd2luZG93LkNvQ3JlYXRlUGlja3IuZGlzYWJsZWRFdmVudCA9IHRydWU7XG4gICAgICAgIHBpY2tySW5zLnNldENvbG9yKHN0eWxlKTtcbiAgICAgICAgd2luZG93LkNvQ3JlYXRlUGlja3IuZGlzYWJsZWRFdmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAvLyBDb0NyZWF0ZS5yZXBsYWNlRGF0YUNyZHQoe1xuICAgICAgICAgICAgLy8gICBjb2xsZWN0aW9uOiAnYnVpbGRlcicsXG4gICAgICAgICAgICAvLyAgIGRvY3VtZW50X2lkOiAnbnVsbCcsXG4gICAgICAgICAgICAvLyAgIG5hbWU6IGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgICAgLy8gICB2YWx1ZTogdmFsdWUgKyAnJyxcbiAgICAgICAgICAgIC8vICAgcG9zaXRpb246ICcwJyxcbiAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHJnYmEyaGV4KHZhbHVlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIENvQ3JlYXRlLnJlcGxhY2VEYXRhQ3JkdCh7XG4gICAgICAgICAgICAvLyAgIGNvbGxlY3Rpb246ICdidWlsZGVyJyxcbiAgICAgICAgICAgIC8vICAgZG9jdW1lbnRfaWQ6ICdudWxsJyxcbiAgICAgICAgICAgIC8vICAgbmFtZTogaW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJyksXG4gICAgICAgICAgICAvLyAgIHZhbHVlOiB2YWx1ZSArICcnLFxuICAgICAgICAgICAgLy8gICBwb3NpdGlvbjogJzAnLFxuICAgICAgICAgICAgLy8gfSlcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlICsgJyc7ICAgICBcbiAgICAgICAgfVxuICAgICAgfVxuXG5cblxuXG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGVJZkRpZmZlcihcImRhdGEtc3R5bGVfdW5pdFwiLCB1bml0IHx8ICcnKTtcbiAgICB9XG5cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRWYWx1ZSh2YWx1ZSwgZGF0YUF0dHJpYnV0ZSwgZGF0YVByb3BlcnR5LCBlbGVtZW50SWQpe1xuICBsZXQgZWxlbWVudCA9IGFsbEZyYW1lKChmcmFtZSkgPT4gZnJhbWUucXVlcnlTZWxlY3RvcihlbGVtZW50SWQpKVswXTtcbiAgbGV0IGNhbWVsRGF0YVByb3BlcnR5ID0gdG9DYW1lbENhc2UoZGF0YVByb3BlcnR5KTtcbiAgIHN3aXRjaCAoZGF0YUF0dHJpYnV0ZSkge1xuICAgICAgY2FzZSBcImNsYXNzc3R5bGVcIjpcbiAgICAgICAgZWxlbWVudC5zZXRDQ1N0eWxlKGRhdGFQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBlbGVtZW50LnNldFN0bHllSWZEaWZmZXIoY2FtZWxEYXRhUHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGNvZGVcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50KGlucHV0TWV0YSwgZWxlbWVudElkLCBpc0NvbGwpIHtcbiAgbGV0IGVsZW1lbnQgPSBhbGxGcmFtZSgoZnJhbWUpID0+IGZyYW1lLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudElkKSlbMF07XG5cbiAgbGV0IHsgaW5wdXQsIGRhdGFQcm9wZXJ0eSwgZGF0YUF0dHJpYnV0ZSB9ID0gaW5wdXRNZXRhO1xuICBsZXQgY2FtZWxEYXRhUHJvcGVydHkgPSB0b0NhbWVsQ2FzZShkYXRhUHJvcGVydHkpO1xuICBsZXQgc3R5bGU7XG5cbiAgaWYgKGlucHV0LmNsYXNzTGlzdC5jb250YWlucygncGlja3InKSkge1xuICAgIGlmICghcGlja3JSZWZzLmhhcyhpbnB1dCkpIHJldHVybjtcbiAgICBsZXQgcGlja3JJbnMgPSBwaWNrclJlZnMuZ2V0KGlucHV0KTtcbiAgICBzdHlsZSA9IHBpY2tySW5zLmdldENvbG9yKCkudG9IRVhBKCkudG9TdHJpbmcoKTtcbiAgICBzd2l0Y2ggKGRhdGFBdHRyaWJ1dGUpIHtcbiAgICAgIGNhc2UgXCJjbGFzc3N0eWxlXCI6XG4gICAgICAgIGVsZW1lbnQuc2V0Q0NTdHlsZShkYXRhUHJvcGVydHksIHN0eWxlKTtcbiAgICAgICAgaXNDb2xsICYmXG4gICAgICAgICAgY29sbGFib3JhdGUoe1xuICAgICAgICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgICAgICAgdW5pdDogJycsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGRhdGFQcm9wZXJ0eSxcbiAgICAgICAgICAgIGRhdGFBdHRyaWJ1dGUsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudElkLFxuICAgICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBlbGVtZW50LnNldFN0bHllSWZEaWZmZXIoY2FtZWxEYXRhUHJvcGVydHksIHN0eWxlKSAmJlxuICAgICAgICAgIGlzQ29sbCAmJlxuICAgICAgICAgIGNvbGxhYm9yYXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBzdHlsZSxcbiAgICAgICAgICAgIHVuaXQ6ICcnLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBkYXRhUHJvcGVydHksXG4gICAgICAgICAgICBkYXRhQXR0cmlidXRlLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnRJZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGNvZGVcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgbGV0IFt2YWx1ZSwgdW5pdF0gPSBwYXJzZVVuaXQoaW5wdXQudmFsdWUpO1xuXG4gICAgdW5pdCA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVfdW5pdFwiKTtcbiAgICBzd2l0Y2ggKGRhdGFBdHRyaWJ1dGUpIHtcbiAgICAgIGNhc2UgXCJjbGFzc3N0eWxlXCI6XG4gICAgICAgIC8vIHdoZW4gaW5wdXQgaXMgZW1wdHkgcmVtb3ZlIHRoYXQgc3R5bGVcbiAgICAgICAgaWYgKCFpbnB1dC52YWx1ZSkge1xuICAgICAgICAgIHJlbW92ZWNjQ3NzU3R5bGUoZWxlbWVudC5jbGFzc0xpc3QsIGRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgaXNDb2xsICYmXG4gICAgICAgICAgICBjb2xsYWJvcmF0ZSh7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgZGF0YVByb3BlcnR5LFxuICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlLFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBlbGVtZW50SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBzdHlsZSBzZXQgdGhhdFxuXG4gICAgICAgIHN0eWxlID0gdmFsdWUgKyB1bml0O1xuICAgICAgICBlbGVtZW50LnNldENDU3R5bGUoZGF0YVByb3BlcnR5LCBzdHlsZSk7XG4gICAgICAgIGlzQ29sbCAmJlxuICAgICAgICAgIGNvbGxhYm9yYXRlKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdW5pdCxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgZGF0YVByb3BlcnR5LFxuICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZSxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50SWQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcblxuICAgICAgICAvLyBsZXQgY29tcHV0ZWRTdHlsZXMgPSBnZXRSZWFsU3RhdGljQ29tcFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAvLyBsZXQgc3R5bGVWYWx1ZSA9IGNvbXB1dGVkU3R5bGVzW2RhdGFQcm9wZXJ0eV07XG4gICAgICAgIGlmICghaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICBlbGVtZW50LnNldFN0bHllSWZEaWZmZXIoY2FtZWxEYXRhUHJvcGVydHksIFwiXCIpICYmXG4gICAgICAgICAgICBpc0NvbGwgJiZcbiAgICAgICAgICAgIGNvbGxhYm9yYXRlKHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBkYXRhUHJvcGVydHksXG4gICAgICAgICAgICAgIGRhdGFBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIGVsZW1lbnRJZCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gZWxlbWVudC5zdHlsZVtkYXRhUHJvcGVydHldID0gXCJcIjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZSA9IHZhbHVlICsgdW5pdDtcbiAgICAgICAgZWxlbWVudC5zZXRTdGx5ZUlmRGlmZmVyKGNhbWVsRGF0YVByb3BlcnR5LCBzdHlsZSkgJiZcbiAgICAgICAgICBpc0NvbGwgJiZcbiAgICAgICAgICBjb2xsYWJvcmF0ZSh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGRhdGFQcm9wZXJ0eSxcbiAgICAgICAgICAgIGRhdGFBdHRyaWJ1dGUsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudElkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBlbGVtZW50LnN0eWxlW2RhdGFQcm9wZXJ0eV0gPSBzdHlsZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbn1cblxuZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGRvIHtcbiAgICBpbmRleCA9IHN0ci5pbmRleE9mKFwiLVwiLCBpbmRleCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGV0IHQgPSBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzdHIuY2hhckNvZGVBdChpbmRleCArIDEpIC0gMzIpO1xuICAgICAgdCArPSBzdHIuc3Vic3RyKGluZGV4ICsgMik7XG4gICAgICBzdHIgPSB0O1xuICAgIH1cbiAgICBlbHNlIGJyZWFrO1xuICB9IHdoaWxlICh0cnVlKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlSWZEaWZmZXIocHJvcGVydHksIHZhbHVlKSB7XG4gIGlmICh0aGlzLmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgIT09IHZhbHVlKVxuICAgIHRoaXMuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHNldFN0bHllSWZEaWZmZXIocHJvcGVydHksIHZhbHVlKSB7XG4gIGxldCBjb21wdXRlZFN0eWxlcyA9IGdldFJlYWxTdGF0aWNDb21wU3R5bGUodGhpcyk7XG4gIGlmIChjb21wdXRlZFN0eWxlc1twcm9wZXJ0eV0gIT09IHZhbHVlKSB7XG4gICAgdGhpcy5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3NJZkRpZmZlcihjbGFzc05hbWUpIHtcbiAgaWYgKCF0aGlzLmNsYXNzTGlzdC5oYXMoY2xhc3NOYW1lKSkgdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHNldENDU3R5bGUocHJvcGVydHksIG5ld1ZhbHVlKSB7XG4gIGZvciAobGV0IGNsYXNzbmFtZSBvZiB0aGlzLmNsYXNzTGlzdCkge1xuICAgIGxldCBbbmFtZSwgdmFsdWVdID0gY2xhc3NuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBpZiAobmFtZSA9PT0gcHJvcGVydHkpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlcGxhY2UoY2xhc3NuYW1lLCBwcm9wZXJ0eSArIFwiOlwiICsgbmV3VmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2xhc3NMaXN0LmFkZChwcm9wZXJ0eSArIFwiOlwiICsgbmV3VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDQ1N0eWxlKHByb3BlcnR5KSB7XG4gIGxldCBzdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgY2xhc3NuYW1lIG9mIHRoaXMuY2xhc3NMaXN0KSB7XG4gICAgbGV0IFtuYW1lLCB2YWx1ZV0gPSBjbGFzc25hbWUuc3BsaXQoXCI6XCIpO1xuICAgIGlmIChuYW1lID09PSBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxubGV0IHRvb2xzID0ge307XG5cbmZ1bmN0aW9uIGluaXQoeyB3aW5kb3dPYmplY3QsIGRvY09iamVjdCwgaXNJZnJhbWUsIGZyYW1lLCBvbkNvbGxhYm9yYXRpb24gfSkge1xuICBsZXQgcmVmO1xuICB0b29scy5vbkNvbGxhYm9yYXRpb24gPSBvbkNvbGxhYm9yYXRpb247XG4gIGlmIChpc0lmcmFtZSkge1xuICAgIGxldCBmcmFtZVdpbmRvdyA9IGZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgbGV0IGZyYW1lRG9jdW1lbnQgPSBmcmFtZVdpbmRvdy5kb2N1bWVudCB8fCBmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG5cbiAgICByZWYgPSB7XG4gICAgICBmcmFtZSxcbiAgICAgIHdpbmRvdzogZnJhbWVXaW5kb3csXG4gICAgICBkb2N1bWVudDogZnJhbWVEb2N1bWVudCxcbiAgICAgIGlzSWZyYW1lOiB0cnVlLFxuICAgIH07XG4gICAgYWxsRnJhbWVzLnNldChmcmFtZSwgcmVmKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZWYgPSB7IHdpbmRvdzogd2luZG93T2JqZWN0LCBkb2N1bWVudDogZG9jT2JqZWN0LCBpc0lmcmFtZTogZmFsc2UgfTtcbiAgICBhbGxGcmFtZXMuc2V0KFwibWFpblwiLCByZWYpO1xuICB9XG5cbiAgcmVmLndpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlSWZEaWZmZXIgPSBzZXRBdHRyaWJ1dGVJZkRpZmZlcjtcbiAgcmVmLndpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0U3RseWVJZkRpZmZlciA9IHNldFN0bHllSWZEaWZmZXI7XG4gIHJlZi53aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmFkZENsYXNzSWZEaWZmZXIgPSBhZGRDbGFzc0lmRGlmZmVyO1xuICByZWYud2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZS5zZXRDQ1N0eWxlID0gc2V0Q0NTdHlsZTtcbiAgcmVmLndpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0Q0NTdHlsZSA9IGdldENDU3R5bGU7XG5cbiAgcmVmLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgcmVmLndpbmRvdy5Db0NyZWF0ZU9ic2VydmVyLmFkZCh7XG4gICAgICBuYW1lOiBcImNjU3R5bGVcIixcbiAgICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIl0sXG4gICAgICBhdHRyaWJ1dGVzOiBbXCJkYXRhLXN0eWxlX3RhcmdldFwiLCBcInZhbHVlXCJdLFxuICAgICAgaW5jbHVkZTogXCJJTlBVVCwgLnBpY2tyXCIsXG4gICAgICB0YXNrOiB3YXRjaElucHV0Q2hhbmdlLFxuICAgIH0pO1xuICB9KTtcblxuICByZWYuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIChlKSA9PiB7XG4gICAgbGV0IGlucHV0ID0gZS50YXJnZXQ7XG5cbiAgICAvLyBpbnB1dC5pc1JlYWN0aXZlID0gdHJ1ZTtcbiAgICBsZXQgaW5wdXRNZXRhID0gdmFsaWRhdGVOZXdJbnB1dChpbnB1dCk7XG4gICAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcblxuICAgIGxldCBlbGVtZW50SWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlX3RhcmdldFwiKTtcbiAgICB1cGRhdGVFbGVtZW50KGlucHV0TWV0YSwgZWxlbWVudElkLCB0cnVlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEZpbHRlcihzZWxlY3Rvcikge1xuICBmaWx0ZXJzLnB1c2goc2VsZWN0b3IpO1xufVxud2luZG93LmNjU3R5bGUgPSB7IGluaXQsIGFkZEZpbHRlciB9O1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICB3aW5kb3cuQ29DcmVhdGVPYnNlcnZlci5hZGQoe1xuICAgIG5hbWU6IFwiY2NTdHlsZVwiLFxuICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIl0sXG4gICAgYXR0cmlidXRlczogW1wiZGF0YS1zdHlsZV90YXJnZXRcIiwgXCJ2YWx1ZVwiXSxcbiAgICBpbmNsdWRlOiBcIklOUFVULCAucGlja3JcIixcbiAgICB0YXNrOiB3YXRjaElucHV0Q2hhbmdlLFxuICB9KTtcblxuICBpbml0KHsgd2luZG93T2JqZWN0OiB3aW5kb3csIGRvY09iamVjdDogZG9jdW1lbnQgfSk7XG59KTtcblxuQ29DcmVhdGVTb2NrZXQubGlzdGVuKFwiY2NTdHlsZVwiLCBmdW5jdGlvbih7XG4gIHZhbHVlLFxuICBkYXRhQXR0cmlidXRlLFxuICBkYXRhUHJvcGVydHksXG4gIGVsZW1lbnRJZCxcbiAgdW5pdFxufSkge1xuICBsZXQgaW5wdXRzID0gYWxsRnJhbWUoKGZyYW1lKSA9PlxuICAgIGZyYW1lLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBgW2RhdGEtc3R5bGU9JHtkYXRhQXR0cmlidXRlfV1bZGF0YS1zdHlsZV9zeW5jPSR7ZGF0YVByb3BlcnR5fV1gXG4gICAgKVxuICApO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICB1cGRhdGVFbGVtZW50VmFsdWUodmFsdWUgKyB1bml0LCBkYXRhQXR0cmlidXRlLCBkYXRhUHJvcGVydHksIGVsZW1lbnRJZCk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGNvbGxhYm9yYXRlKHtcbiAgdmFsdWUsXG4gIGlucHV0LFxuICBkYXRhUHJvcGVydHksXG4gIGRhdGFBdHRyaWJ1dGUsXG4gIGVsZW1lbnRJZCxcbiAgZWxlbWVudCxcbiAgdW5pdCxcbn0pIHtcbiAgLy8gaWYgKHZhbHVlICE9IGlucHV0LnZhbHVlKSByZXR1cm47XG5cbiAgdG9vbHMub25Db2xsYWJvcmF0aW9uKHtcbiAgICB2YWx1ZSxcbiAgICB1bml0LFxuICAgIGRhdGFQcm9wZXJ0eSxcbiAgICBkYXRhQXR0cmlidXRlLFxuICAgIGVsZW1lbnQsXG4gIH0pO1xuXG4gIENvQ3JlYXRlLnNlbmRNZXNzYWdlKHtcbiAgICBicm9hZGNhc3Rfc2VuZGVyOiBmYWxzZSxcbiAgICByb29tczogXCJcIixcbiAgICBlbWl0OiB7XG4gICAgICBtZXNzYWdlOiBcImNjU3R5bGVcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHVuaXQsXG4gICAgICAgIGRhdGFQcm9wZXJ0eSxcbiAgICAgICAgZGF0YUF0dHJpYnV0ZSxcbiAgICAgICAgZWxlbWVudElkLFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcbn1cbiJdLCJmaWxlIjoiLi9zcmMvQ29DcmVhdGUtc3R5bGVzLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/CoCreate-styles.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/CoCreate-styles.js");
/******/ })()
.default;
});